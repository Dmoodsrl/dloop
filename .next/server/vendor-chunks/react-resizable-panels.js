"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resizable-panels";
exports.ids = ["vendor-chunks/react-resizable-panels"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   PanelGroup: () => (/* binding */ PanelGroup),\n/* harmony export */   PanelResizeHandle: () => (/* binding */ PanelResizeHandle),\n/* harmony export */   getAvailableGroupSizePixels: () => (/* binding */ getAvailableGroupSizePixels)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = react__WEBPACK_IMPORTED_MODULE_0__;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = react__WEBPACK_IMPORTED_MODULE_0__[\"useId\".toString()];\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idRef.current;\n}\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nfunction PanelWithForwardedRef({\n  children = null,\n  className: classNameFromProps = \"\",\n  collapsedSize = 0,\n  collapsible = false,\n  defaultSize = null,\n  forwardedRef,\n  id: idFromProps = null,\n  maxSize = null,\n  minSize,\n  onCollapse = null,\n  onResize = null,\n  order = null,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const panelId = useUniqueId(idFromProps);\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    registerPanel,\n    resizePanel,\n    units,\n    unregisterPanel\n  } = context;\n  if (minSize == null) {\n    if (units === \"percentages\") {\n      // Mimics legacy default value for percentage based panel groups\n      minSize = 10;\n    } else {\n      // There is no meaningful minimum pixel default we can provide\n      minSize = 0;\n    }\n  }\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onCollapse,\n    onResize\n  });\n  useEffect(() => {\n    callbacksRef.current.onCollapse = onCollapse;\n    callbacksRef.current.onResize = onResize;\n  });\n  const style = getPanelStyle(panelId, defaultSize);\n  const committedValuesRef = useRef({\n    size: parseSizeFromStyle(style)\n  });\n  useRef({\n    callbacksRef,\n    collapsedSize,\n    collapsible,\n    defaultSize,\n    id: panelId,\n    idWasAutoGenerated: idFromProps == null,\n    maxSize,\n    minSize,\n    order\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => collapsePanel(panelId),\n    expand: () => expandPanel(panelId),\n    getCollapsed() {\n      return committedValuesRef.current.size === 0;\n    },\n    getId() {\n      return panelId;\n    },\n    getSize(units) {\n      return getPanelSize(panelId, units);\n    },\n    resize: (percentage, units) => resizePanel(panelId, percentage, units)\n  }), [collapsePanel, expandPanel, getPanelSize, panelId, resizePanel]);\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1),\n    id: `data-panel-id-${panelId}`,\n    style: {\n      ...style,\n      ...styleFromProps\n    }\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\n// HACK\nfunction parseSizeFromStyle(style) {\n  const {\n    flexGrow\n  } = style;\n  if (typeof flexGrow === \"string\") {\n    return parseFloat(flexGrow);\n  } else {\n    return flexGrow;\n  }\n}\n\nconst PRECISION = 10;\n\nfunction adjustByDelta(event, committedValues, idBefore, idAfter, deltaPixels, prevSizes, panelSizeBeforeCollapse, initialDragState) {\n  const {\n    id: groupId,\n    panels,\n    units\n  } = committedValues;\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  const {\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  const panelsArray = panelsMapToSortedArray(panels);\n  const nextSizes = baseSizes.concat();\n  let deltaApplied = 0;\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel immediately after the resizer should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel immediately before the resizer should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resizer.\n\n  // Max-bounds check the panel being expanded first.\n  {\n    const pivotId = deltaPixels < 0 ? idAfter : idBefore;\n    const index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize + Math.abs(deltaPixels), event);\n    if (baseSize === nextSize) {\n      // If there's no room for the pivot panel to grow, we can ignore this drag update.\n      return baseSizes;\n    } else {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(pivotId, baseSize);\n      }\n      deltaPixels = deltaPixels < 0 ? baseSize - nextSize : nextSize - baseSize;\n    }\n  }\n  let pivotId = deltaPixels < 0 ? idBefore : idAfter;\n  let index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  while (true) {\n    const panel = panelsArray[index];\n    const baseSize = baseSizes[index];\n    const deltaRemaining = Math.abs(deltaPixels) - Math.abs(deltaApplied);\n    const nextSize = safeResizePanel(units, groupSizePixels, panel, baseSize, baseSize - deltaRemaining, event);\n    if (baseSize !== nextSize) {\n      if (nextSize === 0 && baseSize > 0) {\n        panelSizeBeforeCollapse.set(panel.current.id, baseSize);\n      }\n      deltaApplied += baseSize - nextSize;\n      nextSizes[index] = nextSize;\n      if (deltaApplied.toPrecision(PRECISION).localeCompare(Math.abs(deltaPixels).toPrecision(PRECISION), undefined, {\n        numeric: true\n      }) >= 0) {\n        break;\n      }\n    }\n    if (deltaPixels < 0) {\n      if (--index < 0) {\n        break;\n      }\n    } else {\n      if (++index >= panelsArray.length) {\n        break;\n      }\n    }\n  }\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore the \"mousemove\" event.\n  if (deltaApplied === 0) {\n    return baseSizes;\n  }\n\n  // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n  pivotId = deltaPixels < 0 ? idAfter : idBefore;\n  index = panelsArray.findIndex(panel => panel.current.id === pivotId);\n  nextSizes[index] = baseSizes[index] + deltaApplied;\n  return nextSizes;\n}\nfunction callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap) {\n  sizes.forEach((size, index) => {\n    const panelRef = panelsArray[index];\n    if (!panelRef) {\n      // Handle initial mount (when panels are registered too late to be in the panels array)\n      // The subsequent render+effects will handle the resize notification\n      return;\n    }\n    const {\n      callbacksRef,\n      collapsedSize,\n      collapsible,\n      id\n    } = panelRef.current;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[id];\n    if (lastNotifiedSize !== size) {\n      panelIdToLastNotifiedSizeMap[id] = size;\n      const {\n        onCollapse,\n        onResize\n      } = callbacksRef.current;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && onCollapse) {\n        if ((lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n          onCollapse(false);\n        } else if (lastNotifiedSize !== collapsedSize && size === collapsedSize) {\n          onCollapse(true);\n        }\n      }\n    }\n  });\n}\nfunction getBeforeAndAfterIds(id, panelsArray) {\n  if (panelsArray.length < 2) {\n    return [null, null];\n  }\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  if (index < 0) {\n    return [null, null];\n  }\n  const isLastPanel = index === panelsArray.length - 1;\n  const idBefore = isLastPanel ? panelsArray[index - 1].current.id : id;\n  const idAfter = isLastPanel ? id : panelsArray[index + 1].current.id;\n  return [idBefore, idAfter];\n}\nfunction getAvailableGroupSizePixels(groupId) {\n  const panelGroupElement = getPanelGroup(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n  const direction = panelGroupElement.getAttribute(\"data-panel-group-direction\");\n  const resizeHandles = getResizeHandlesForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return panelGroupElement.offsetWidth - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetWidth;\n    }, 0);\n  } else {\n    return panelGroupElement.offsetHeight - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetHeight;\n    }, 0);\n  }\n}\n\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction getFlexGrow(panels, id, sizes) {\n  if (panels.size === 1) {\n    return \"100\";\n  }\n  const panelsArray = panelsMapToSortedArray(panels);\n  const index = panelsArray.findIndex(panel => panel.current.id === id);\n  const size = sizes[index];\n  if (size == null) {\n    return \"0\";\n  }\n  return size.toPrecision(PRECISION);\n}\nfunction getPanel(id) {\n  const element = document.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getPanelGroup(id) {\n  const element = document.querySelector(`[data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandle(id) {\n  const element = document.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\nfunction getResizeHandleIndex(id) {\n  const handles = getResizeHandles();\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index ?? null;\n}\nfunction getResizeHandles() {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id]`));\n}\nfunction getResizeHandlesForGroup(groupId) {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray) {\n  const handle = getResizeHandle(handleId);\n  const handles = getResizeHandlesForGroup(groupId);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = panelsArray[index]?.current?.id ?? null;\n  const idAfter = panelsArray[index + 1]?.current?.id ?? null;\n  return [idBefore, idAfter];\n}\nfunction panelsMapToSortedArray(panels) {\n  return Array.from(panels.values()).sort((panelA, panelB) => {\n    const orderA = panelA.current.order;\n    const orderB = panelB.current.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize, event = null) {\n  let {\n    collapsedSize,\n    collapsible,\n    maxSize,\n    minSize\n  } = panel.current;\n  if (units === \"pixels\") {\n    collapsedSize = collapsedSize / groupSizePixels * 100;\n    if (maxSize != null) {\n      maxSize = maxSize / groupSizePixels * 100;\n    }\n    minSize = minSize / groupSizePixels * 100;\n  }\n  if (collapsible) {\n    if (prevSize > collapsedSize) {\n      // Mimic VS COde behavior; collapse a panel if it's smaller than half of its min-size\n      if (nextSize <= minSize / 2 + collapsedSize) {\n        return collapsedSize;\n      }\n    } else {\n      const isKeyboardEvent = event?.type?.startsWith(\"key\");\n      if (!isKeyboardEvent) {\n        // Keyboard events should expand a collapsed panel to the min size,\n        // but mouse events should wait until the panel has reached its min size\n        // to avoid a visual flickering when dragging between collapsed and min size.\n        if (nextSize < minSize) {\n          return collapsedSize;\n        }\n      }\n    }\n  }\n  return Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n}\nfunction validatePanelProps(units, panelData) {\n  const {\n    collapsible,\n    defaultSize,\n    maxSize,\n    minSize\n  } = panelData.current;\n\n  // Basic props validation\n  if (minSize < 0 || units === \"percentages\" && minSize > 100) {\n    {\n      console.error(`Invalid Panel minSize provided, ${minSize}`);\n    }\n    panelData.current.minSize = 0;\n  }\n  if (maxSize != null) {\n    if (maxSize < 0 || units === \"percentages\" && maxSize > 100) {\n      {\n        console.error(`Invalid Panel maxSize provided, ${maxSize}`);\n      }\n      panelData.current.maxSize = null;\n    }\n  }\n  if (defaultSize !== null) {\n    if (defaultSize < 0 || units === \"percentages\" && defaultSize > 100) {\n      {\n        console.error(`Invalid Panel defaultSize provided, ${defaultSize}`);\n      }\n      panelData.current.defaultSize = null;\n    } else if (defaultSize < minSize && !collapsible) {\n      {\n        console.error(`Panel minSize (${minSize}) cannot be greater than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = minSize;\n    } else if (maxSize != null && defaultSize > maxSize) {\n      {\n        console.error(`Panel maxSize (${maxSize}) cannot be less than defaultSize (${defaultSize})`);\n      }\n      panelData.current.defaultSize = maxSize;\n    }\n  }\n}\nfunction validatePanelGroupLayout({\n  groupId,\n  panels,\n  nextSizes,\n  prevSizes,\n  units\n}) {\n  // Clone because this method modifies\n  nextSizes = [...nextSizes];\n  const panelsArray = panelsMapToSortedArray(panels);\n  const groupSizePixels = units === \"pixels\" ? getAvailableGroupSizePixels(groupId) : NaN;\n  let remainingSize = 0;\n\n  // First, check all of the proposed sizes against the min/max constraints\n  for (let index = 0; index < panelsArray.length; index++) {\n    const panel = panelsArray[index];\n    const prevSize = prevSizes[index];\n    const nextSize = nextSizes[index];\n    const safeNextSize = safeResizePanel(units, groupSizePixels, panel, prevSize, nextSize);\n    if (nextSize != safeNextSize) {\n      remainingSize += nextSize - safeNextSize;\n      nextSizes[index] = safeNextSize;\n      {\n        console.error(`Invalid size (${nextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n      }\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    for (let index = 0; index < panelsArray.length; index++) {\n      const panel = panelsArray[index];\n      let {\n        maxSize,\n        minSize\n      } = panel.current;\n      if (units === \"pixels\") {\n        minSize = minSize / groupSizePixels * 100;\n        if (maxSize != null) {\n          maxSize = maxSize / groupSizePixels * 100;\n        }\n      }\n      const size = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSizes[index] + remainingSize));\n      if (size !== nextSizes[index]) {\n        remainingSize -= size - nextSizes[index];\n        nextSizes[index] = size;\n\n        // Fuzzy comparison to account for imprecise floating point math\n        if (Math.abs(remainingSize).toFixed(3) === \"0.000\") {\n          break;\n        }\n      }\n    }\n  }\n\n  // If we still have remainder, the requested layout wasn't valid and we should warn about it\n  if (remainingSize.toFixed(3) !== \"0.000\") {\n    {\n      console.error(`\"Invalid panel group configuration; default panel sizes should total 100% but was ${100 - remainingSize}%`);\n    }\n  }\n  return nextSizes;\n}\n\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  groupId,\n  panels,\n  setSizes,\n  sizes,\n  panelSizeBeforeCollapse\n}) {\n  useEffect(() => {\n    const {\n      direction,\n      panels\n    } = committedValuesRef.current;\n    const groupElement = getPanelGroup(groupId);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const {\n      height,\n      width\n    } = groupElement.getBoundingClientRect();\n    const handles = getResizeHandlesForGroup(groupId);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      let currentMinSize = 0;\n      let currentMaxSize = 100;\n      let totalMinSize = 0;\n      let totalMaxSize = 0;\n\n      // A panel's effective min/max sizes also need to account for other panel's sizes.\n      panelsArray.forEach(panelData => {\n        const {\n          id,\n          maxSize,\n          minSize\n        } = panelData.current;\n        if (id === idBefore) {\n          currentMinSize = minSize;\n          currentMaxSize = maxSize != null ? maxSize : 100;\n        } else {\n          totalMinSize += minSize;\n          totalMaxSize += maxSize != null ? maxSize : 100;\n        }\n      });\n      const ariaValueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n      const ariaValueMin = Math.max(currentMinSize, (panelsArray.length - 1) * 100 - totalMaxSize);\n      const flexGrow = getFlexGrow(panels, idBefore, sizes);\n      handle.setAttribute(\"aria-valuemax\", \"\" + Math.round(ariaValueMax));\n      handle.setAttribute(\"aria-valuemin\", \"\" + Math.round(ariaValueMin));\n      handle.setAttribute(\"aria-valuenow\", \"\" + Math.round(parseInt(flexGrow)));\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelsArray.findIndex(panel => panel.current.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelsArray[index];\n                const size = sizes[index];\n                if (size != null) {\n                  let delta = 0;\n                  if (size.toPrecision(PRECISION) <= panelData.current.minSize.toPrecision(PRECISION)) {\n                    delta = direction === \"horizontal\" ? width : height;\n                  } else {\n                    delta = -(direction === \"horizontal\" ? width : height);\n                  }\n                  const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, sizes, panelSizeBeforeCollapse.current, null);\n                  if (sizes !== nextSizes) {\n                    setSizes(nextSizes);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      const panelBefore = getPanel(idBefore);\n      if (panelBefore != null) {\n        handle.setAttribute(\"aria-controls\", panelBefore.id);\n      }\n      return () => {\n        handle.removeAttribute(\"aria-valuemax\");\n        handle.removeAttribute(\"aria-valuemin\");\n        handle.removeAttribute(\"aria-valuenow\");\n        handle.removeEventListener(\"keydown\", onKeyDown);\n        if (panelBefore != null) {\n          handle.removeAttribute(\"aria-controls\");\n        }\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [committedValuesRef, groupId, panels, panelSizeBeforeCollapse, setSizes, sizes]);\n}\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const handleElement = getResizeHandle(handleId);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const handles = getResizeHandles();\n            const index = getResizeHandleIndex(handleId);\n            assert(index !== null);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getDragOffset(event, handleId, direction, initialOffset = 0, initialHandleElementRect = null) {\n  const isHorizontal = direction === \"horizontal\";\n  let pointerOffset = 0;\n  if (isMouseEvent(event)) {\n    pointerOffset = isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    pointerOffset = isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    return 0;\n  }\n  const handleElement = getResizeHandle(handleId);\n  const rect = initialHandleElementRect || handleElement.getBoundingClientRect();\n  const elementOffset = isHorizontal ? rect.left : rect.top;\n  return pointerOffset - elementOffset - initialOffset;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragState) {\n  const {\n    dragOffset = 0,\n    dragHandleRect,\n    sizes: initialSizes\n  } = initialDragState || {};\n\n  // If we're resizing by mouse or touch, use the initial sizes as a base.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const baseSizes = initialSizes || prevSizes;\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    const groupElement = getPanelGroup(groupId);\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n    const denominator = event.shiftKey ? 10 : 100;\n    const delta = groupSizeInPixels / denominator;\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = groupSizeInPixels;\n        break;\n      case \"Home\":\n        movement = -groupSizeInPixels;\n        break;\n    }\n\n    // If the Panel being resized is collapsible,\n    // we need to special case resizing around the minSize boundary.\n    // If contracting, Panels should shrink to their minSize and then snap to fully collapsed.\n    // If expanding from collapsed, they should snap back to their minSize.\n    const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n    const targetPanelId = movement < 0 ? idBefore : idAfter;\n    const targetPanelIndex = panelsArray.findIndex(panel => panel.current.id === targetPanelId);\n    const targetPanel = panelsArray[targetPanelIndex];\n    if (targetPanel.current.collapsible) {\n      const baseSize = baseSizes[targetPanelIndex];\n      if (baseSize === 0 || baseSize.toPrecision(PRECISION) === targetPanel.current.minSize.toPrecision(PRECISION)) {\n        movement = movement < 0 ? -targetPanel.current.minSize * groupSizeInPixels : targetPanel.current.minSize * groupSizeInPixels;\n      }\n    }\n    return movement;\n  } else {\n    return getDragOffset(event, handleId, direction, dragOffset, dragHandleRect);\n  }\n}\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n  return event.type.startsWith(\"touch\");\n}\n\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"ns-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n  }\n}\nfunction setGlobalCursorStyle(state) {\n  if (currentState === state) {\n    return;\n  }\n  currentState = state;\n  const style = getCursorStyle(state);\n  if (element === null) {\n    element = document.createElement(\"style\");\n    document.head.appendChild(element);\n  }\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using an attribute like minSize instead should work well enough.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels) {\n  return panels.map(panel => {\n    const {\n      minSize,\n      order\n    } = panel.current;\n    return order ? `${order}:${minSize}` : `${minSize}`;\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction savePanelGroupLayout(autoSaveId, panels, sizes, storage) {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n  state[key] = sizes;\n  try {\n    storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nconst debounceMap = {};\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\n\n// Initial drag state serves a few purposes:\n// * dragOffset:\n//   Resize is calculated by the distance between the current pointer event and the resize handle being \"dragged\"\n//   This value accounts for the initial offset when the touch/click starts, so the handle doesn't appear to \"jump\"\n// * dragHandleRect, sizes:\n//   When resizing is done via mouse/touch event– some initial state is stored\n//   so that any panels that contract will also expand if drag direction is reversed.\nfunction PanelGroupWithForwardedRef({\n  autoSaveId,\n  children = null,\n  className: classNameFromProps = \"\",\n  direction,\n  disablePointerEventsDuringResize = false,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout,\n  storage = defaultStorage,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n  units = \"percentages\"\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const [activeHandleId, setActiveHandleId] = useState(null);\n  const [panels, setPanels] = useState(new Map());\n\n  // When resizing is done via mouse/touch event–\n  // We store the initial Panel sizes in this ref, and apply move deltas to them instead of to the current sizes.\n  // This has the benefit of causing force-collapsed panels to spring back open if drag is reversed.\n  const initialDragStateRef = useRef(null);\n  const devWarningsRef = useRef({\n    didLogDefaultSizeWarning: false,\n    didLogIdAndOrderWarning: false,\n    didLogInvalidLayoutWarning: false,\n    prevPanelIds: []\n  });\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onLayout\n  });\n  useEffect(() => {\n    callbacksRef.current.onLayout = onLayout;\n  });\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n\n  // 0-1 values representing the relative size of each panel.\n  const [sizes, setSizes] = useState([]);\n\n  // Used to support imperative collapse/expand API.\n  const panelSizeBeforeCollapse = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n\n  // Store committed values to avoid unnecessarily re-running memoization/effects functions.\n  const committedValuesRef = useRef({\n    direction,\n    id: groupId,\n    panels,\n    sizes,\n    units\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => groupId,\n    getLayout: unitsFromParams => {\n      const {\n        sizes,\n        units: unitsFromProps\n      } = committedValuesRef.current;\n      const units = unitsFromParams ?? unitsFromProps;\n      if (units === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        return sizes.map(size => size / 100 * groupSizePixels);\n      } else {\n        return sizes;\n      }\n    },\n    setLayout: (sizes, unitsFromParams) => {\n      const {\n        id: groupId,\n        panels,\n        sizes: prevSizes,\n        units\n      } = committedValuesRef.current;\n      if ((unitsFromParams || units) === \"pixels\") {\n        const groupSizePixels = getAvailableGroupSizePixels(groupId);\n        sizes = sizes.map(size => size / groupSizePixels * 100);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const nextSizes = validatePanelGroupLayout({\n        groupId,\n        panels,\n        nextSizes: sizes,\n        prevSizes,\n        units\n      });\n      if (!areEqual(prevSizes, nextSizes)) {\n        setSizes(nextSizes);\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n    }\n  }), [groupId]);\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    groupId,\n    panels,\n    setSizes,\n    sizes,\n    panelSizeBeforeCollapse\n  });\n\n  // Notify external code when sizes have changed.\n  useEffect(() => {\n    const {\n      onLayout\n    } = callbacksRef.current;\n    const {\n      panels,\n      sizes\n    } = committedValuesRef.current;\n\n    // Don't commit layout until all panels have registered and re-rendered with their actual sizes.\n    if (sizes.length > 0) {\n      if (onLayout) {\n        onLayout(sizes);\n      }\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n      // When possible, we notify before the next render so that rendering work can be batched together.\n      // Some cases are difficult to detect though,\n      // for example– panels that are conditionally rendered can affect the size of neighboring panels.\n      // In this case, the best we can do is notify on commit.\n      // The callPanelCallbacks() uses its own memoization to avoid notifying panels twice in these cases.\n      const panelsArray = panelsMapToSortedArray(panels);\n      callPanelCallbacks(panelsArray, sizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, [sizes]);\n  useEffect(() => {\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (sizes.length === 0 || sizes.length !== panels.size) {\n        return;\n      }\n      const panelsArray = panelsMapToSortedArray(panels);\n\n      // Limit the frequency of localStorage updates.\n      if (!debounceMap[autoSaveId]) {\n        debounceMap[autoSaveId] = debounce(savePanelGroupLayout, 100);\n      }\n      debounceMap[autoSaveId](autoSaveId, panelsArray, sizes, storage);\n    }\n    {\n      const {\n        didLogIdAndOrderWarning,\n        prevPanelIds\n      } = devWarningsRef.current;\n      if (!didLogIdAndOrderWarning) {\n        const {\n          panels\n        } = committedValuesRef.current;\n        const panelIds = Array.from(panels.keys());\n        devWarningsRef.current.prevPanelIds = panelIds;\n        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (Array.from(panels.values()).find(panel => panel.current.idWasAutoGenerated || panel.current.order == null)) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n          }\n        }\n      }\n    }\n  }, [autoSaveId, panels, sizes, storage]);\n  const getPanelSize = useCallback((id, unitsFromParams) => {\n    const {\n      panels,\n      units: unitsFromProps\n    } = committedValuesRef.current;\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.findIndex(panel => panel.current.id === id);\n    const size = sizes[index];\n    const units = unitsFromParams ?? unitsFromProps;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      return size / 100 * groupSizePixels;\n    } else {\n      return size;\n    }\n  }, [groupId, sizes]);\n  const getPanelStyle = useCallback((id, defaultSize) => {\n    const {\n      panels\n    } = committedValuesRef.current;\n\n    // Before mounting, Panels will not yet have registered themselves.\n    // This includes server rendering.\n    // At this point the best we can do is render everything with the same size.\n    if (panels.size === 0) {\n      {\n        if (!devWarningsRef.current.didLogDefaultSizeWarning) {\n          if (defaultSize == null) {\n            devWarningsRef.current.didLogDefaultSizeWarning = true;\n            console.warn(`WARNING: Panel defaultSize prop recommended to avoid layout shift after server rendering`);\n          }\n        }\n      }\n      return {\n        flexBasis: 0,\n        flexGrow: defaultSize != null ? defaultSize : undefined,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content.\n        overflow: \"hidden\"\n      };\n    }\n    const flexGrow = getFlexGrow(panels, id, sizes);\n    return {\n      flexBasis: 0,\n      flexGrow,\n      flexShrink: 1,\n      // Without this, Panel sizes may be unintentionally overridden by their content.\n      overflow: \"hidden\",\n      // Disable pointer events inside of a panel during resize.\n      // This avoid edge cases like nested iframes.\n      pointerEvents: disablePointerEventsDuringResize && activeHandleId !== null ? \"none\" : undefined\n    };\n  }, [activeHandleId, disablePointerEventsDuringResize, sizes]);\n  const registerPanel = useCallback((id, panelRef) => {\n    const {\n      units\n    } = committedValuesRef.current;\n    validatePanelProps(units, panelRef);\n    setPanels(prevPanels => {\n      if (prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.set(id, panelRef);\n      return nextPanels;\n    });\n  }, []);\n  const registerResizeHandle = useCallback(handleId => {\n    const resizeHandler = event => {\n      event.preventDefault();\n      const {\n        direction,\n        panels,\n        sizes: prevSizes\n      } = committedValuesRef.current;\n      const panelsArray = panelsMapToSortedArray(panels);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelsArray);\n      if (idBefore == null || idAfter == null) {\n        return;\n      }\n      let movement = getMovement(event, groupId, handleId, panelsArray, direction, prevSizes, initialDragStateRef.current);\n      if (movement === 0) {\n        return;\n      }\n      const groupElement = getPanelGroup(groupId);\n      const rect = groupElement.getBoundingClientRect();\n      const isHorizontal = direction === \"horizontal\";\n\n      // Support RTL layouts\n      if (document.dir === \"rtl\" && isHorizontal) {\n        movement = -movement;\n      }\n      const size = isHorizontal ? rect.width : rect.height;\n      const delta = movement / size * 100;\n\n      // If a validateLayout method has been provided\n      // it's important to use it before updating the mouse cursor\n      const nextSizes = adjustByDelta(event, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, initialDragStateRef.current);\n      const sizesChanged = !areEqual(prevSizes, nextSizes);\n\n      // Don't update cursor for resizes triggered by keyboard interactions.\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          if (!sizesChanged) {\n            // If the pointer has moved too far to resize the panel any further,\n            // update the cursor style for a visual clue.\n            // This mimics VS Code behavior.\n\n            if (isHorizontal) {\n              setGlobalCursorStyle(movement < 0 ? \"horizontal-min\" : \"horizontal-max\");\n            } else {\n              setGlobalCursorStyle(movement < 0 ? \"vertical-min\" : \"vertical-max\");\n            }\n          } else {\n            // Reset the cursor style to the the normal resize cursor.\n            setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n          }\n        }\n      }\n      if (sizesChanged) {\n        const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n\n        // It's okay to bypass in this case because we already validated above\n        setSizes(nextSizes);\n\n        // If resize change handlers have been declared, this is the time to call them.\n        // Trigger user callbacks after updating state, so that user code can override the sizes.\n        callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n      }\n      prevDeltaRef.current = delta;\n    };\n    return resizeHandler;\n  }, [groupId]);\n  const unregisterPanel = useCallback(id => {\n    setPanels(prevPanels => {\n      if (!prevPanels.has(id)) {\n        return prevPanels;\n      }\n      const nextPanels = new Map(prevPanels);\n      nextPanels.delete(id);\n      return nextPanels;\n    });\n  }, []);\n  const collapsePanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      collapsible\n    } = panel.current;\n    if (!collapsible) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === collapsedSize) {\n      // Panel is already collapsed.\n      return;\n    }\n    panelSizeBeforeCollapse.current.set(id, currentSize);\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize : collapsedSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const expandPanel = useCallback(id => {\n    const {\n      panels,\n      sizes: prevSizes\n    } = committedValuesRef.current;\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    const {\n      collapsedSize,\n      minSize\n    } = panel.current;\n    const sizeBeforeCollapse = panelSizeBeforeCollapse.current.get(id) || minSize;\n    if (!sizeBeforeCollapse) {\n      return;\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize !== collapsedSize) {\n      // Panel is already expanded.\n      return;\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? collapsedSize - sizeBeforeCollapse : sizeBeforeCollapse;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const resizePanel = useCallback((id, nextSize, unitsFromParams) => {\n    const {\n      id: groupId,\n      panels,\n      sizes: prevSizes,\n      units\n    } = committedValuesRef.current;\n    if ((unitsFromParams || units) === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      nextSize = nextSize / groupSizePixels * 100;\n    }\n    const panel = panels.get(id);\n    if (panel == null) {\n      return;\n    }\n    let {\n      collapsedSize,\n      collapsible,\n      maxSize,\n      minSize\n    } = panel.current;\n    if (units === \"pixels\") {\n      const groupSizePixels = getAvailableGroupSizePixels(groupId);\n      minSize = minSize / groupSizePixels * 100;\n      if (maxSize != null) {\n        maxSize = maxSize / groupSizePixels * 100;\n      }\n    }\n    const panelsArray = panelsMapToSortedArray(panels);\n    const index = panelsArray.indexOf(panel);\n    if (index < 0) {\n      return;\n    }\n    const currentSize = prevSizes[index];\n    if (currentSize === nextSize) {\n      return;\n    }\n    if (collapsible && nextSize === collapsedSize) ; else {\n      const unsafeNextSize = nextSize;\n      nextSize = Math.min(maxSize != null ? maxSize : 100, Math.max(minSize, nextSize));\n      {\n        if (unsafeNextSize !== nextSize) {\n          console.error(`Invalid size (${unsafeNextSize}) specified for Panel \"${panel.current.id}\" given the panel's min/max size constraints`);\n        }\n      }\n    }\n    const [idBefore, idAfter] = getBeforeAndAfterIds(id, panelsArray);\n    if (idBefore == null || idAfter == null) {\n      return;\n    }\n    const isLastPanel = index === panelsArray.length - 1;\n    const delta = isLastPanel ? currentSize - nextSize : nextSize - currentSize;\n    const nextSizes = adjustByDelta(null, committedValuesRef.current, idBefore, idAfter, delta, prevSizes, panelSizeBeforeCollapse.current, null);\n    if (prevSizes !== nextSizes) {\n      const panelIdToLastNotifiedSizeMap = panelIdToLastNotifiedSizeMapRef.current;\n      setSizes(nextSizes);\n\n      // If resize change handlers have been declared, this is the time to call them.\n      // Trigger user callbacks after updating state, so that user code can override the sizes.\n      callPanelCallbacks(panelsArray, nextSizes, panelIdToLastNotifiedSizeMap);\n    }\n  }, []);\n  const context = useMemo(() => ({\n    activeHandleId,\n    collapsePanel,\n    direction,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging: (id, event) => {\n      setActiveHandleId(id);\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        const handleElement = getResizeHandle(id);\n        initialDragStateRef.current = {\n          dragHandleRect: handleElement.getBoundingClientRect(),\n          dragOffset: getDragOffset(event, id, direction),\n          sizes: committedValuesRef.current.sizes\n        };\n      }\n    },\n    stopDragging: () => {\n      resetGlobalCursorStyle();\n      setActiveHandleId(null);\n      initialDragStateRef.current = null;\n    },\n    units,\n    unregisterPanel\n  }), [activeHandleId, collapsePanel, direction, expandPanel, getPanelSize, getPanelStyle, groupId, registerPanel, registerResizeHandle, resizePanel, units, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    children: createElement(Type, {\n      children,\n      className: classNameFromProps,\n      \"data-panel-group\": \"\",\n      \"data-panel-group-direction\": direction,\n      \"data-panel-group-id\": groupId,\n      \"data-panel-group-units\": units,\n      style: {\n        ...style,\n        ...styleFromProps\n      }\n    }),\n    value: context\n  });\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  id: idFromProps = null,\n  onDragging,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const divElementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    activeHandleId,\n    direction,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = activeHandleId === resizeHandleId;\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current;\n    div.blur();\n    stopDragging();\n    const {\n      onDragging\n    } = callbacksRef.current;\n    if (onDragging) {\n      onDragging(false);\n    }\n  }, [stopDragging]);\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n    const onMove = event => {\n      resizeHandler(event);\n    };\n    const onMouseLeave = event => {\n      resizeHandler(event);\n    };\n    const divElement = divElementRef.current;\n    const targetDocument = divElement.ownerDocument;\n    targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    targetDocument.body.addEventListener(\"mousemove\", onMove);\n    targetDocument.body.addEventListener(\"touchmove\", onMove);\n    targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n    return () => {\n      targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n      targetDocument.body.removeEventListener(\"mousemove\", onMove);\n      targetDocument.body.removeEventListener(\"touchmove\", onMove);\n      targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler\n  });\n  const style = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex: 0\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlLXBhbmVscy9kaXN0L3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMuZGV2ZWxvcG1lbnQubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCOztBQUUvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsa0NBQUs7O0FBRVQsMkRBQTJELFFBQVE7QUFDbkUsY0FBYyxrQ0FBSzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxHQUFHO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csUUFBUTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxZQUFZO0FBQ3pFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3Q0FBd0MsUUFBUSx3Q0FBd0MsWUFBWTtBQUNwRztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0NBQXdDLFFBQVEscUNBQXFDLFlBQVk7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVMseUJBQXlCLGlCQUFpQjtBQUMxRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0RBQWdELG9CQUFvQjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVLE1BQU0sWUFBWTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLE1BQU0sR0FBRyxRQUFRLE9BQU8sUUFBUTtBQUN0RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGVBQWUseUJBQXlCLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUU2RSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUtcGFuZWxzL2Rpc3QvcmVhY3QtcmVzaXphYmxlLXBhbmVscy5kZXZlbG9wbWVudC5ub2RlLmVzbS5qcz83YWU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVGhpcyBtb2R1bGUgZXhpc3RzIHRvIHdvcmsgYXJvdW5kIFdlYnBhY2sgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTQ4MTRcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuXG5jb25zdCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZUNvbnRleHQsXG4gIGZvcndhcmRSZWYsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0LFxuICB1c2VFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZUxheW91dEVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgdXNlUmVmLFxuICB1c2VTdGF0ZVxufSA9IFJlYWN0O1xuXG4vLyBgdG9TdHJpbmcoKWAgcHJldmVudHMgYnVuZGxlcnMgZnJvbSB0cnlpbmcgdG8gYGltcG9ydCB7IHVzZUlkIH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlSWQgPSBSZWFjdFtcInVzZUlkXCIudG9TdHJpbmcoKV07XG5cbmNvbnN0IHdyYXBwZWRVc2VJZCA9IHR5cGVvZiB1c2VJZCA9PT0gXCJmdW5jdGlvblwiID8gdXNlSWQgOiAoKSA9PiBudWxsO1xubGV0IGNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gdXNlVW5pcXVlSWQoaWRGcm9tUGFyYW1zID0gbnVsbCkge1xuICBjb25zdCBpZEZyb21Vc2VJZCA9IHdyYXBwZWRVc2VJZCgpO1xuICBjb25zdCBpZFJlZiA9IHVzZVJlZihpZEZyb21QYXJhbXMgfHwgaWRGcm9tVXNlSWQgfHwgbnVsbCk7XG4gIGlmIChpZFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgaWRSZWYuY3VycmVudCA9IFwiXCIgKyBjb3VudGVyKys7XG4gIH1cbiAgcmV0dXJuIGlkUmVmLmN1cnJlbnQ7XG59XG5cbmNvbnN0IFBhbmVsR3JvdXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcblBhbmVsR3JvdXBDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJQYW5lbEdyb3VwQ29udGV4dFwiO1xuXG5mdW5jdGlvbiBQYW5lbFdpdGhGb3J3YXJkZWRSZWYoe1xuICBjaGlsZHJlbiA9IG51bGwsXG4gIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzID0gXCJcIixcbiAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gIGNvbGxhcHNpYmxlID0gZmFsc2UsXG4gIGRlZmF1bHRTaXplID0gbnVsbCxcbiAgZm9yd2FyZGVkUmVmLFxuICBpZDogaWRGcm9tUHJvcHMgPSBudWxsLFxuICBtYXhTaXplID0gbnVsbCxcbiAgbWluU2l6ZSxcbiAgb25Db2xsYXBzZSA9IG51bGwsXG4gIG9uUmVzaXplID0gbnVsbCxcbiAgb3JkZXIgPSBudWxsLFxuICBzdHlsZTogc3R5bGVGcm9tUHJvcHMgPSB7fSxcbiAgdGFnTmFtZTogVHlwZSA9IFwiZGl2XCJcbn0pIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUGFuZWxHcm91cENvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IEVycm9yKGBQYW5lbCBjb21wb25lbnRzIG11c3QgYmUgcmVuZGVyZWQgd2l0aGluIGEgUGFuZWxHcm91cCBjb250YWluZXJgKTtcbiAgfVxuICBjb25zdCBwYW5lbElkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCB7XG4gICAgY29sbGFwc2VQYW5lbCxcbiAgICBleHBhbmRQYW5lbCxcbiAgICBnZXRQYW5lbFNpemUsXG4gICAgZ2V0UGFuZWxTdHlsZSxcbiAgICByZWdpc3RlclBhbmVsLFxuICAgIHJlc2l6ZVBhbmVsLFxuICAgIHVuaXRzLFxuICAgIHVucmVnaXN0ZXJQYW5lbFxuICB9ID0gY29udGV4dDtcbiAgaWYgKG1pblNpemUgPT0gbnVsbCkge1xuICAgIGlmICh1bml0cyA9PT0gXCJwZXJjZW50YWdlc1wiKSB7XG4gICAgICAvLyBNaW1pY3MgbGVnYWN5IGRlZmF1bHQgdmFsdWUgZm9yIHBlcmNlbnRhZ2UgYmFzZWQgcGFuZWwgZ3JvdXBzXG4gICAgICBtaW5TaXplID0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIG1lYW5pbmdmdWwgbWluaW11bSBwaXhlbCBkZWZhdWx0IHdlIGNhbiBwcm92aWRlXG4gICAgICBtaW5TaXplID0gMDtcbiAgICB9XG4gIH1cblxuICAvLyBVc2UgYSByZWYgdG8gZ3VhcmQgYWdhaW5zdCB1c2VycyBwYXNzaW5nIGlubGluZSBwcm9wc1xuICBjb25zdCBjYWxsYmFja3NSZWYgPSB1c2VSZWYoe1xuICAgIG9uQ29sbGFwc2UsXG4gICAgb25SZXNpemVcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25Db2xsYXBzZSA9IG9uQ29sbGFwc2U7XG4gICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25SZXNpemUgPSBvblJlc2l6ZTtcbiAgfSk7XG4gIGNvbnN0IHN0eWxlID0gZ2V0UGFuZWxTdHlsZShwYW5lbElkLCBkZWZhdWx0U2l6ZSk7XG4gIGNvbnN0IGNvbW1pdHRlZFZhbHVlc1JlZiA9IHVzZVJlZih7XG4gICAgc2l6ZTogcGFyc2VTaXplRnJvbVN0eWxlKHN0eWxlKVxuICB9KTtcbiAgdXNlUmVmKHtcbiAgICBjYWxsYmFja3NSZWYsXG4gICAgY29sbGFwc2VkU2l6ZSxcbiAgICBjb2xsYXBzaWJsZSxcbiAgICBkZWZhdWx0U2l6ZSxcbiAgICBpZDogcGFuZWxJZCxcbiAgICBpZFdhc0F1dG9HZW5lcmF0ZWQ6IGlkRnJvbVByb3BzID09IG51bGwsXG4gICAgbWF4U2l6ZSxcbiAgICBtaW5TaXplLFxuICAgIG9yZGVyXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4gKHtcbiAgICBjb2xsYXBzZTogKCkgPT4gY29sbGFwc2VQYW5lbChwYW5lbElkKSxcbiAgICBleHBhbmQ6ICgpID0+IGV4cGFuZFBhbmVsKHBhbmVsSWQpLFxuICAgIGdldENvbGxhcHNlZCgpIHtcbiAgICAgIHJldHVybiBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudC5zaXplID09PSAwO1xuICAgIH0sXG4gICAgZ2V0SWQoKSB7XG4gICAgICByZXR1cm4gcGFuZWxJZDtcbiAgICB9LFxuICAgIGdldFNpemUodW5pdHMpIHtcbiAgICAgIHJldHVybiBnZXRQYW5lbFNpemUocGFuZWxJZCwgdW5pdHMpO1xuICAgIH0sXG4gICAgcmVzaXplOiAocGVyY2VudGFnZSwgdW5pdHMpID0+IHJlc2l6ZVBhbmVsKHBhbmVsSWQsIHBlcmNlbnRhZ2UsIHVuaXRzKVxuICB9KSwgW2NvbGxhcHNlUGFuZWwsIGV4cGFuZFBhbmVsLCBnZXRQYW5lbFNpemUsIHBhbmVsSWQsIHJlc2l6ZVBhbmVsXSk7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICBjaGlsZHJlbixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyxcbiAgICBcImRhdGEtcGFuZWxcIjogXCJcIixcbiAgICBcImRhdGEtcGFuZWwtY29sbGFwc2libGVcIjogY29sbGFwc2libGUgfHwgdW5kZWZpbmVkLFxuICAgIFwiZGF0YS1wYW5lbC1pZFwiOiBwYW5lbElkLFxuICAgIFwiZGF0YS1wYW5lbC1zaXplXCI6IHBhcnNlRmxvYXQoXCJcIiArIHN0eWxlLmZsZXhHcm93KS50b0ZpeGVkKDEpLFxuICAgIGlkOiBgZGF0YS1wYW5lbC1pZC0ke3BhbmVsSWR9YCxcbiAgICBzdHlsZToge1xuICAgICAgLi4uc3R5bGUsXG4gICAgICAuLi5zdHlsZUZyb21Qcm9wc1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBQYW5lbCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoUGFuZWxXaXRoRm9yd2FyZGVkUmVmLCB7XG4gIC4uLnByb3BzLFxuICBmb3J3YXJkZWRSZWY6IHJlZlxufSkpO1xuUGFuZWxXaXRoRm9yd2FyZGVkUmVmLmRpc3BsYXlOYW1lID0gXCJQYW5lbFwiO1xuUGFuZWwuZGlzcGxheU5hbWUgPSBcImZvcndhcmRSZWYoUGFuZWwpXCI7XG5cbi8vIEhBQ0tcbmZ1bmN0aW9uIHBhcnNlU2l6ZUZyb21TdHlsZShzdHlsZSkge1xuICBjb25zdCB7XG4gICAgZmxleEdyb3dcbiAgfSA9IHN0eWxlO1xuICBpZiAodHlwZW9mIGZsZXhHcm93ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoZmxleEdyb3cpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmbGV4R3JvdztcbiAgfVxufVxuXG5jb25zdCBQUkVDSVNJT04gPSAxMDtcblxuZnVuY3Rpb24gYWRqdXN0QnlEZWx0YShldmVudCwgY29tbWl0dGVkVmFsdWVzLCBpZEJlZm9yZSwgaWRBZnRlciwgZGVsdGFQaXhlbHMsIHByZXZTaXplcywgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UsIGluaXRpYWxEcmFnU3RhdGUpIHtcbiAgY29uc3Qge1xuICAgIGlkOiBncm91cElkLFxuICAgIHBhbmVscyxcbiAgICB1bml0c1xuICB9ID0gY29tbWl0dGVkVmFsdWVzO1xuICBjb25zdCBncm91cFNpemVQaXhlbHMgPSB1bml0cyA9PT0gXCJwaXhlbHNcIiA/IGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyhncm91cElkKSA6IE5hTjtcbiAgY29uc3Qge1xuICAgIHNpemVzOiBpbml0aWFsU2l6ZXNcbiAgfSA9IGluaXRpYWxEcmFnU3RhdGUgfHwge307XG5cbiAgLy8gSWYgd2UncmUgcmVzaXppbmcgYnkgbW91c2Ugb3IgdG91Y2gsIHVzZSB0aGUgaW5pdGlhbCBzaXplcyBhcyBhIGJhc2UuXG4gIC8vIFRoaXMgaGFzIHRoZSBiZW5lZml0IG9mIGNhdXNpbmcgZm9yY2UtY29sbGFwc2VkIHBhbmVscyB0byBzcHJpbmcgYmFjayBvcGVuIGlmIGRyYWcgaXMgcmV2ZXJzZWQuXG4gIGNvbnN0IGJhc2VTaXplcyA9IGluaXRpYWxTaXplcyB8fCBwcmV2U2l6ZXM7XG4gIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICBjb25zdCBuZXh0U2l6ZXMgPSBiYXNlU2l6ZXMuY29uY2F0KCk7XG4gIGxldCBkZWx0YUFwcGxpZWQgPSAwO1xuXG4gIC8vIEEgcmVzaXppbmcgcGFuZWwgYWZmZWN0cyB0aGUgcGFuZWxzIGJlZm9yZSBvciBhZnRlciBpdC5cbiAgLy9cbiAgLy8gQSBuZWdhdGl2ZSBkZWx0YSBtZWFucyB0aGUgcGFuZWwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHJlc2l6ZXIgc2hvdWxkIGdyb3cvZXhwYW5kIGJ5IGRlY3JlYXNpbmcgaXRzIG9mZnNldC5cbiAgLy8gT3RoZXIgcGFuZWxzIG1heSBhbHNvIG5lZWQgdG8gc2hyaW5rL2NvbnRyYWN0IChhbmQgc2hpZnQpIHRvIG1ha2Ugcm9vbSwgZGVwZW5kaW5nIG9uIHRoZSBtaW4gd2VpZ2h0cy5cbiAgLy9cbiAgLy8gQSBwb3NpdGl2ZSBkZWx0YSBtZWFucyB0aGUgcGFuZWwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSByZXNpemVyIHNob3VsZCBcImV4cGFuZFwiLlxuICAvLyBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBzaHJpbmtpbmcvY29udHJhY3RpbmcgKGFuZCBzaGlmdGluZykgb25lIG9yIG1vcmUgb2YgdGhlIHBhbmVscyBhZnRlciB0aGUgcmVzaXplci5cblxuICAvLyBNYXgtYm91bmRzIGNoZWNrIHRoZSBwYW5lbCBiZWluZyBleHBhbmRlZCBmaXJzdC5cbiAge1xuICAgIGNvbnN0IHBpdm90SWQgPSBkZWx0YVBpeGVscyA8IDAgPyBpZEFmdGVyIDogaWRCZWZvcmU7XG4gICAgY29uc3QgaW5kZXggPSBwYW5lbHNBcnJheS5maW5kSW5kZXgocGFuZWwgPT4gcGFuZWwuY3VycmVudC5pZCA9PT0gcGl2b3RJZCk7XG4gICAgY29uc3QgcGFuZWwgPSBwYW5lbHNBcnJheVtpbmRleF07XG4gICAgY29uc3QgYmFzZVNpemUgPSBiYXNlU2l6ZXNbaW5kZXhdO1xuICAgIGNvbnN0IG5leHRTaXplID0gc2FmZVJlc2l6ZVBhbmVsKHVuaXRzLCBncm91cFNpemVQaXhlbHMsIHBhbmVsLCBiYXNlU2l6ZSwgYmFzZVNpemUgKyBNYXRoLmFicyhkZWx0YVBpeGVscyksIGV2ZW50KTtcbiAgICBpZiAoYmFzZVNpemUgPT09IG5leHRTaXplKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHJvb20gZm9yIHRoZSBwaXZvdCBwYW5lbCB0byBncm93LCB3ZSBjYW4gaWdub3JlIHRoaXMgZHJhZyB1cGRhdGUuXG4gICAgICByZXR1cm4gYmFzZVNpemVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFNpemUgPT09IDAgJiYgYmFzZVNpemUgPiAwKSB7XG4gICAgICAgIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLnNldChwaXZvdElkLCBiYXNlU2l6ZSk7XG4gICAgICB9XG4gICAgICBkZWx0YVBpeGVscyA9IGRlbHRhUGl4ZWxzIDwgMCA/IGJhc2VTaXplIC0gbmV4dFNpemUgOiBuZXh0U2l6ZSAtIGJhc2VTaXplO1xuICAgIH1cbiAgfVxuICBsZXQgcGl2b3RJZCA9IGRlbHRhUGl4ZWxzIDwgMCA/IGlkQmVmb3JlIDogaWRBZnRlcjtcbiAgbGV0IGluZGV4ID0gcGFuZWxzQXJyYXkuZmluZEluZGV4KHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWQgPT09IHBpdm90SWQpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHBhbmVsID0gcGFuZWxzQXJyYXlbaW5kZXhdO1xuICAgIGNvbnN0IGJhc2VTaXplID0gYmFzZVNpemVzW2luZGV4XTtcbiAgICBjb25zdCBkZWx0YVJlbWFpbmluZyA9IE1hdGguYWJzKGRlbHRhUGl4ZWxzKSAtIE1hdGguYWJzKGRlbHRhQXBwbGllZCk7XG4gICAgY29uc3QgbmV4dFNpemUgPSBzYWZlUmVzaXplUGFuZWwodW5pdHMsIGdyb3VwU2l6ZVBpeGVscywgcGFuZWwsIGJhc2VTaXplLCBiYXNlU2l6ZSAtIGRlbHRhUmVtYWluaW5nLCBldmVudCk7XG4gICAgaWYgKGJhc2VTaXplICE9PSBuZXh0U2l6ZSkge1xuICAgICAgaWYgKG5leHRTaXplID09PSAwICYmIGJhc2VTaXplID4gMCkge1xuICAgICAgICBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZS5zZXQocGFuZWwuY3VycmVudC5pZCwgYmFzZVNpemUpO1xuICAgICAgfVxuICAgICAgZGVsdGFBcHBsaWVkICs9IGJhc2VTaXplIC0gbmV4dFNpemU7XG4gICAgICBuZXh0U2l6ZXNbaW5kZXhdID0gbmV4dFNpemU7XG4gICAgICBpZiAoZGVsdGFBcHBsaWVkLnRvUHJlY2lzaW9uKFBSRUNJU0lPTikubG9jYWxlQ29tcGFyZShNYXRoLmFicyhkZWx0YVBpeGVscykudG9QcmVjaXNpb24oUFJFQ0lTSU9OKSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIG51bWVyaWM6IHRydWVcbiAgICAgIH0pID49IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWx0YVBpeGVscyA8IDApIHtcbiAgICAgIGlmICgtLWluZGV4IDwgMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCsraW5kZXggPj0gcGFuZWxzQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIHdlcmUgdW5hYmxlIHRvIHJlc2l6ZSBhbnkgb2YgdGhlIHBhbmVscyBwYW5lbHMsIHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuXG4gIC8vIFRoaXMgd2lsbCBlc3NlbnRpYWxseSBiYWlsb3V0IGFuZCBpZ25vcmUgdGhlIFwibW91c2Vtb3ZlXCIgZXZlbnQuXG4gIGlmIChkZWx0YUFwcGxpZWQgPT09IDApIHtcbiAgICByZXR1cm4gYmFzZVNpemVzO1xuICB9XG5cbiAgLy8gQWRqdXN0IHRoZSBwaXZvdCBwYW5lbCBiZWZvcmUsIGJ1dCBvbmx5IGJ5IHRoZSBhbW91bnQgdGhhdCBzdXJyb3VuZGluZyBwYW5lbHMgd2VyZSBhYmxlIHRvIHNocmluay9jb250cmFjdC5cbiAgcGl2b3RJZCA9IGRlbHRhUGl4ZWxzIDwgMCA/IGlkQWZ0ZXIgOiBpZEJlZm9yZTtcbiAgaW5kZXggPSBwYW5lbHNBcnJheS5maW5kSW5kZXgocGFuZWwgPT4gcGFuZWwuY3VycmVudC5pZCA9PT0gcGl2b3RJZCk7XG4gIG5leHRTaXplc1tpbmRleF0gPSBiYXNlU2l6ZXNbaW5kZXhdICsgZGVsdGFBcHBsaWVkO1xuICByZXR1cm4gbmV4dFNpemVzO1xufVxuZnVuY3Rpb24gY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsc0FycmF5LCBzaXplcywgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCkge1xuICBzaXplcy5mb3JFYWNoKChzaXplLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhbmVsUmVmID0gcGFuZWxzQXJyYXlbaW5kZXhdO1xuICAgIGlmICghcGFuZWxSZWYpIHtcbiAgICAgIC8vIEhhbmRsZSBpbml0aWFsIG1vdW50ICh3aGVuIHBhbmVscyBhcmUgcmVnaXN0ZXJlZCB0b28gbGF0ZSB0byBiZSBpbiB0aGUgcGFuZWxzIGFycmF5KVxuICAgICAgLy8gVGhlIHN1YnNlcXVlbnQgcmVuZGVyK2VmZmVjdHMgd2lsbCBoYW5kbGUgdGhlIHJlc2l6ZSBub3RpZmljYXRpb25cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FsbGJhY2tzUmVmLFxuICAgICAgY29sbGFwc2VkU2l6ZSxcbiAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgaWRcbiAgICB9ID0gcGFuZWxSZWYuY3VycmVudDtcbiAgICBjb25zdCBsYXN0Tm90aWZpZWRTaXplID0gcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFtpZF07XG4gICAgaWYgKGxhc3ROb3RpZmllZFNpemUgIT09IHNpemUpIHtcbiAgICAgIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBbaWRdID0gc2l6ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25Db2xsYXBzZSxcbiAgICAgICAgb25SZXNpemVcbiAgICAgIH0gPSBjYWxsYmFja3NSZWYuY3VycmVudDtcbiAgICAgIGlmIChvblJlc2l6ZSkge1xuICAgICAgICBvblJlc2l6ZShzaXplLCBsYXN0Tm90aWZpZWRTaXplKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzaWJsZSAmJiBvbkNvbGxhcHNlKSB7XG4gICAgICAgIGlmICgobGFzdE5vdGlmaWVkU2l6ZSA9PSBudWxsIHx8IGxhc3ROb3RpZmllZFNpemUgPT09IGNvbGxhcHNlZFNpemUpICYmIHNpemUgIT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgICBvbkNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0Tm90aWZpZWRTaXplICE9PSBjb2xsYXBzZWRTaXplICYmIHNpemUgPT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgICBvbkNvbGxhcHNlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEJlZm9yZUFuZEFmdGVySWRzKGlkLCBwYW5lbHNBcnJheSkge1xuICBpZiAocGFuZWxzQXJyYXkubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cbiAgY29uc3QgaW5kZXggPSBwYW5lbHNBcnJheS5maW5kSW5kZXgocGFuZWwgPT4gcGFuZWwuY3VycmVudC5pZCA9PT0gaWQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgfVxuICBjb25zdCBpc0xhc3RQYW5lbCA9IGluZGV4ID09PSBwYW5lbHNBcnJheS5sZW5ndGggLSAxO1xuICBjb25zdCBpZEJlZm9yZSA9IGlzTGFzdFBhbmVsID8gcGFuZWxzQXJyYXlbaW5kZXggLSAxXS5jdXJyZW50LmlkIDogaWQ7XG4gIGNvbnN0IGlkQWZ0ZXIgPSBpc0xhc3RQYW5lbCA/IGlkIDogcGFuZWxzQXJyYXlbaW5kZXggKyAxXS5jdXJyZW50LmlkO1xuICByZXR1cm4gW2lkQmVmb3JlLCBpZEFmdGVyXTtcbn1cbmZ1bmN0aW9uIGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyhncm91cElkKSB7XG4gIGNvbnN0IHBhbmVsR3JvdXBFbGVtZW50ID0gZ2V0UGFuZWxHcm91cChncm91cElkKTtcbiAgaWYgKHBhbmVsR3JvdXBFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIGNvbnN0IGRpcmVjdGlvbiA9IHBhbmVsR3JvdXBFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uXCIpO1xuICBjb25zdCByZXNpemVIYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlc0Zvckdyb3VwKGdyb3VwSWQpO1xuICBpZiAoZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgIHJldHVybiBwYW5lbEdyb3VwRWxlbWVudC5vZmZzZXRXaWR0aCAtIHJlc2l6ZUhhbmRsZXMucmVkdWNlKChhY2N1bXVsYXRlZCwgaGFuZGxlKSA9PiB7XG4gICAgICByZXR1cm4gYWNjdW11bGF0ZWQgKyBoYW5kbGUub2Zmc2V0V2lkdGg7XG4gICAgfSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhbmVsR3JvdXBFbGVtZW50Lm9mZnNldEhlaWdodCAtIHJlc2l6ZUhhbmRsZXMucmVkdWNlKChhY2N1bXVsYXRlZCwgaGFuZGxlKSA9PiB7XG4gICAgICByZXR1cm4gYWNjdW11bGF0ZWQgKyBoYW5kbGUub2Zmc2V0SGVpZ2h0O1xuICAgIH0sIDApO1xuICB9XG59XG5cbi8vIFRoaXMgbWV0aG9kIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCAxMDAgcmVwcmVzZW50aW5nXG4vLyB0aGUgJSBvZiB0aGUgZ3JvdXAncyBvdmVyYWxsIHNwYWNlIHRoaXMgcGFuZWwgc2hvdWxkIG9jY3VweS5cbmZ1bmN0aW9uIGdldEZsZXhHcm93KHBhbmVscywgaWQsIHNpemVzKSB7XG4gIGlmIChwYW5lbHMuc2l6ZSA9PT0gMSkge1xuICAgIHJldHVybiBcIjEwMFwiO1xuICB9XG4gIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICBjb25zdCBpbmRleCA9IHBhbmVsc0FycmF5LmZpbmRJbmRleChwYW5lbCA9PiBwYW5lbC5jdXJyZW50LmlkID09PSBpZCk7XG4gIGNvbnN0IHNpemUgPSBzaXplc1tpbmRleF07XG4gIGlmIChzaXplID09IG51bGwpIHtcbiAgICByZXR1cm4gXCIwXCI7XG4gIH1cbiAgcmV0dXJuIHNpemUudG9QcmVjaXNpb24oUFJFQ0lTSU9OKTtcbn1cbmZ1bmN0aW9uIGdldFBhbmVsKGlkKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYW5lbC1pZD1cIiR7aWR9XCJdYCk7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRQYW5lbEdyb3VwKGlkKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYW5lbC1ncm91cC1pZD1cIiR7aWR9XCJdYCk7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGUoaWQpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWQ9XCIke2lkfVwiXWApO1xuICBpZiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlSW5kZXgoaWQpIHtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZXMoKTtcbiAgY29uc3QgaW5kZXggPSBoYW5kbGVzLmZpbmRJbmRleChoYW5kbGUgPT4gaGFuZGxlLmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZFwiKSA9PT0gaWQpO1xuICByZXR1cm4gaW5kZXggPz8gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZXMoKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRdYCkpO1xufVxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlc0Zvckdyb3VwKGdyb3VwSWQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZF1bZGF0YS1wYW5lbC1ncm91cC1pZD1cIiR7Z3JvdXBJZH1cIl1gKSk7XG59XG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVQYW5lbElkcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxzQXJyYXkpIHtcbiAgY29uc3QgaGFuZGxlID0gZ2V0UmVzaXplSGFuZGxlKGhhbmRsZUlkKTtcbiAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZXNGb3JHcm91cChncm91cElkKTtcbiAgY29uc3QgaW5kZXggPSBoYW5kbGUgPyBoYW5kbGVzLmluZGV4T2YoaGFuZGxlKSA6IC0xO1xuICBjb25zdCBpZEJlZm9yZSA9IHBhbmVsc0FycmF5W2luZGV4XT8uY3VycmVudD8uaWQgPz8gbnVsbDtcbiAgY29uc3QgaWRBZnRlciA9IHBhbmVsc0FycmF5W2luZGV4ICsgMV0/LmN1cnJlbnQ/LmlkID8/IG51bGw7XG4gIHJldHVybiBbaWRCZWZvcmUsIGlkQWZ0ZXJdO1xufVxuZnVuY3Rpb24gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20ocGFuZWxzLnZhbHVlcygpKS5zb3J0KChwYW5lbEEsIHBhbmVsQikgPT4ge1xuICAgIGNvbnN0IG9yZGVyQSA9IHBhbmVsQS5jdXJyZW50Lm9yZGVyO1xuICAgIGNvbnN0IG9yZGVyQiA9IHBhbmVsQi5jdXJyZW50Lm9yZGVyO1xuICAgIGlmIChvcmRlckEgPT0gbnVsbCAmJiBvcmRlckIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChvcmRlckEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAob3JkZXJCID09IG51bGwpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3JkZXJBIC0gb3JkZXJCO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzYWZlUmVzaXplUGFuZWwodW5pdHMsIGdyb3VwU2l6ZVBpeGVscywgcGFuZWwsIHByZXZTaXplLCBuZXh0U2l6ZSwgZXZlbnQgPSBudWxsKSB7XG4gIGxldCB7XG4gICAgY29sbGFwc2VkU2l6ZSxcbiAgICBjb2xsYXBzaWJsZSxcbiAgICBtYXhTaXplLFxuICAgIG1pblNpemVcbiAgfSA9IHBhbmVsLmN1cnJlbnQ7XG4gIGlmICh1bml0cyA9PT0gXCJwaXhlbHNcIikge1xuICAgIGNvbGxhcHNlZFNpemUgPSBjb2xsYXBzZWRTaXplIC8gZ3JvdXBTaXplUGl4ZWxzICogMTAwO1xuICAgIGlmIChtYXhTaXplICE9IG51bGwpIHtcbiAgICAgIG1heFNpemUgPSBtYXhTaXplIC8gZ3JvdXBTaXplUGl4ZWxzICogMTAwO1xuICAgIH1cbiAgICBtaW5TaXplID0gbWluU2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgfVxuICBpZiAoY29sbGFwc2libGUpIHtcbiAgICBpZiAocHJldlNpemUgPiBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAvLyBNaW1pYyBWUyBDT2RlIGJlaGF2aW9yOyBjb2xsYXBzZSBhIHBhbmVsIGlmIGl0J3Mgc21hbGxlciB0aGFuIGhhbGYgb2YgaXRzIG1pbi1zaXplXG4gICAgICBpZiAobmV4dFNpemUgPD0gbWluU2l6ZSAvIDIgKyBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAgIHJldHVybiBjb2xsYXBzZWRTaXplO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc0tleWJvYXJkRXZlbnQgPSBldmVudD8udHlwZT8uc3RhcnRzV2l0aChcImtleVwiKTtcbiAgICAgIGlmICghaXNLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIC8vIEtleWJvYXJkIGV2ZW50cyBzaG91bGQgZXhwYW5kIGEgY29sbGFwc2VkIHBhbmVsIHRvIHRoZSBtaW4gc2l6ZSxcbiAgICAgICAgLy8gYnV0IG1vdXNlIGV2ZW50cyBzaG91bGQgd2FpdCB1bnRpbCB0aGUgcGFuZWwgaGFzIHJlYWNoZWQgaXRzIG1pbiBzaXplXG4gICAgICAgIC8vIHRvIGF2b2lkIGEgdmlzdWFsIGZsaWNrZXJpbmcgd2hlbiBkcmFnZ2luZyBiZXR3ZWVuIGNvbGxhcHNlZCBhbmQgbWluIHNpemUuXG4gICAgICAgIGlmIChuZXh0U2l6ZSA8IG1pblNpemUpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGFwc2VkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5taW4obWF4U2l6ZSAhPSBudWxsID8gbWF4U2l6ZSA6IDEwMCwgTWF0aC5tYXgobWluU2l6ZSwgbmV4dFNpemUpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUGFuZWxQcm9wcyh1bml0cywgcGFuZWxEYXRhKSB7XG4gIGNvbnN0IHtcbiAgICBjb2xsYXBzaWJsZSxcbiAgICBkZWZhdWx0U2l6ZSxcbiAgICBtYXhTaXplLFxuICAgIG1pblNpemVcbiAgfSA9IHBhbmVsRGF0YS5jdXJyZW50O1xuXG4gIC8vIEJhc2ljIHByb3BzIHZhbGlkYXRpb25cbiAgaWYgKG1pblNpemUgPCAwIHx8IHVuaXRzID09PSBcInBlcmNlbnRhZ2VzXCIgJiYgbWluU2l6ZSA+IDEwMCkge1xuICAgIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgUGFuZWwgbWluU2l6ZSBwcm92aWRlZCwgJHttaW5TaXplfWApO1xuICAgIH1cbiAgICBwYW5lbERhdGEuY3VycmVudC5taW5TaXplID0gMDtcbiAgfVxuICBpZiAobWF4U2l6ZSAhPSBudWxsKSB7XG4gICAgaWYgKG1heFNpemUgPCAwIHx8IHVuaXRzID09PSBcInBlcmNlbnRhZ2VzXCIgJiYgbWF4U2l6ZSA+IDEwMCkge1xuICAgICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIFBhbmVsIG1heFNpemUgcHJvdmlkZWQsICR7bWF4U2l6ZX1gKTtcbiAgICAgIH1cbiAgICAgIHBhbmVsRGF0YS5jdXJyZW50Lm1heFNpemUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmYXVsdFNpemUgIT09IG51bGwpIHtcbiAgICBpZiAoZGVmYXVsdFNpemUgPCAwIHx8IHVuaXRzID09PSBcInBlcmNlbnRhZ2VzXCIgJiYgZGVmYXVsdFNpemUgPiAxMDApIHtcbiAgICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBQYW5lbCBkZWZhdWx0U2l6ZSBwcm92aWRlZCwgJHtkZWZhdWx0U2l6ZX1gKTtcbiAgICAgIH1cbiAgICAgIHBhbmVsRGF0YS5jdXJyZW50LmRlZmF1bHRTaXplID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRTaXplIDwgbWluU2l6ZSAmJiAhY29sbGFwc2libGUpIHtcbiAgICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgUGFuZWwgbWluU2l6ZSAoJHttaW5TaXplfSkgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBkZWZhdWx0U2l6ZSAoJHtkZWZhdWx0U2l6ZX0pYCk7XG4gICAgICB9XG4gICAgICBwYW5lbERhdGEuY3VycmVudC5kZWZhdWx0U2l6ZSA9IG1pblNpemU7XG4gICAgfSBlbHNlIGlmIChtYXhTaXplICE9IG51bGwgJiYgZGVmYXVsdFNpemUgPiBtYXhTaXplKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFBhbmVsIG1heFNpemUgKCR7bWF4U2l6ZX0pIGNhbm5vdCBiZSBsZXNzIHRoYW4gZGVmYXVsdFNpemUgKCR7ZGVmYXVsdFNpemV9KWApO1xuICAgICAgfVxuICAgICAgcGFuZWxEYXRhLmN1cnJlbnQuZGVmYXVsdFNpemUgPSBtYXhTaXplO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQYW5lbEdyb3VwTGF5b3V0KHtcbiAgZ3JvdXBJZCxcbiAgcGFuZWxzLFxuICBuZXh0U2l6ZXMsXG4gIHByZXZTaXplcyxcbiAgdW5pdHNcbn0pIHtcbiAgLy8gQ2xvbmUgYmVjYXVzZSB0aGlzIG1ldGhvZCBtb2RpZmllc1xuICBuZXh0U2l6ZXMgPSBbLi4ubmV4dFNpemVzXTtcbiAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gIGNvbnN0IGdyb3VwU2l6ZVBpeGVscyA9IHVuaXRzID09PSBcInBpeGVsc1wiID8gZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzKGdyb3VwSWQpIDogTmFOO1xuICBsZXQgcmVtYWluaW5nU2l6ZSA9IDA7XG5cbiAgLy8gRmlyc3QsIGNoZWNrIGFsbCBvZiB0aGUgcHJvcG9zZWQgc2l6ZXMgYWdhaW5zdCB0aGUgbWluL21heCBjb25zdHJhaW50c1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFuZWxzQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgcGFuZWwgPSBwYW5lbHNBcnJheVtpbmRleF07XG4gICAgY29uc3QgcHJldlNpemUgPSBwcmV2U2l6ZXNbaW5kZXhdO1xuICAgIGNvbnN0IG5leHRTaXplID0gbmV4dFNpemVzW2luZGV4XTtcbiAgICBjb25zdCBzYWZlTmV4dFNpemUgPSBzYWZlUmVzaXplUGFuZWwodW5pdHMsIGdyb3VwU2l6ZVBpeGVscywgcGFuZWwsIHByZXZTaXplLCBuZXh0U2l6ZSk7XG4gICAgaWYgKG5leHRTaXplICE9IHNhZmVOZXh0U2l6ZSkge1xuICAgICAgcmVtYWluaW5nU2l6ZSArPSBuZXh0U2l6ZSAtIHNhZmVOZXh0U2l6ZTtcbiAgICAgIG5leHRTaXplc1tpbmRleF0gPSBzYWZlTmV4dFNpemU7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2l6ZSAoJHtuZXh0U2l6ZX0pIHNwZWNpZmllZCBmb3IgUGFuZWwgXCIke3BhbmVsLmN1cnJlbnQuaWR9XCIgZ2l2ZW4gdGhlIHBhbmVsJ3MgbWluL21heCBzaXplIGNvbnN0cmFpbnRzYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUgaXMgYWRkaXRpb25hbCwgbGVmdCBvdmVyIHNwYWNlLCBhc3NpZ24gaXQgdG8gYW55IHBhbmVsKHMpIHRoYXQgcGVybWl0cyBpdFxuICAvLyAoSXQncyBub3Qgd29ydGggdGFraW5nIG11bHRpcGxlIGFkZGl0aW9uYWwgcGFzc2VzIHRvIGV2ZW5seSBkaXN0cmlidXRlKVxuICBpZiAocmVtYWluaW5nU2l6ZS50b0ZpeGVkKDMpICE9PSBcIjAuMDAwXCIpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFuZWxzQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBwYW5lbCA9IHBhbmVsc0FycmF5W2luZGV4XTtcbiAgICAgIGxldCB7XG4gICAgICAgIG1heFNpemUsXG4gICAgICAgIG1pblNpemVcbiAgICAgIH0gPSBwYW5lbC5jdXJyZW50O1xuICAgICAgaWYgKHVuaXRzID09PSBcInBpeGVsc1wiKSB7XG4gICAgICAgIG1pblNpemUgPSBtaW5TaXplIC8gZ3JvdXBTaXplUGl4ZWxzICogMTAwO1xuICAgICAgICBpZiAobWF4U2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgbWF4U2l6ZSA9IG1heFNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbihtYXhTaXplICE9IG51bGwgPyBtYXhTaXplIDogMTAwLCBNYXRoLm1heChtaW5TaXplLCBuZXh0U2l6ZXNbaW5kZXhdICsgcmVtYWluaW5nU2l6ZSkpO1xuICAgICAgaWYgKHNpemUgIT09IG5leHRTaXplc1tpbmRleF0pIHtcbiAgICAgICAgcmVtYWluaW5nU2l6ZSAtPSBzaXplIC0gbmV4dFNpemVzW2luZGV4XTtcbiAgICAgICAgbmV4dFNpemVzW2luZGV4XSA9IHNpemU7XG5cbiAgICAgICAgLy8gRnV6enkgY29tcGFyaXNvbiB0byBhY2NvdW50IGZvciBpbXByZWNpc2UgZmxvYXRpbmcgcG9pbnQgbWF0aFxuICAgICAgICBpZiAoTWF0aC5hYnMocmVtYWluaW5nU2l6ZSkudG9GaXhlZCgzKSA9PT0gXCIwLjAwMFwiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBzdGlsbCBoYXZlIHJlbWFpbmRlciwgdGhlIHJlcXVlc3RlZCBsYXlvdXQgd2Fzbid0IHZhbGlkIGFuZCB3ZSBzaG91bGQgd2FybiBhYm91dCBpdFxuICBpZiAocmVtYWluaW5nU2l6ZS50b0ZpeGVkKDMpICE9PSBcIjAuMDAwXCIpIHtcbiAgICB7XG4gICAgICBjb25zb2xlLmVycm9yKGBcIkludmFsaWQgcGFuZWwgZ3JvdXAgY29uZmlndXJhdGlvbjsgZGVmYXVsdCBwYW5lbCBzaXplcyBzaG91bGQgdG90YWwgMTAwJSBidXQgd2FzICR7MTAwIC0gcmVtYWluaW5nU2l6ZX0lYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0U2l6ZXM7XG59XG5cbmZ1bmN0aW9uIGFzc2VydChleHBlY3RlZENvbmRpdGlvbiwgbWVzc2FnZSA9IFwiQXNzZXJ0aW9uIGZhaWxlZCFcIikge1xuICBpZiAoIWV4cGVjdGVkQ29uZGl0aW9uKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB0aHJvdyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL3dpbmRvd3NwbGl0dGVyL1xuXG5mdW5jdGlvbiB1c2VXaW5kb3dTcGxpdHRlclBhbmVsR3JvdXBCZWhhdmlvcih7XG4gIGNvbW1pdHRlZFZhbHVlc1JlZixcbiAgZ3JvdXBJZCxcbiAgcGFuZWxzLFxuICBzZXRTaXplcyxcbiAgc2l6ZXMsXG4gIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlXG59KSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcGFuZWxzXG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IGdldFBhbmVsR3JvdXAoZ3JvdXBJZCk7XG4gICAgYXNzZXJ0KGdyb3VwRWxlbWVudCAhPSBudWxsLCBgTm8gZ3JvdXAgZm91bmQgZm9yIGlkIFwiJHtncm91cElkfVwiYCk7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGhcbiAgICB9ID0gZ3JvdXBFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGhhbmRsZXMgPSBnZXRSZXNpemVIYW5kbGVzRm9yR3JvdXAoZ3JvdXBJZCk7XG4gICAgY29uc3QgY2xlYW51cEZ1bmN0aW9ucyA9IGhhbmRsZXMubWFwKGhhbmRsZSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVJZCA9IGhhbmRsZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRcIik7XG4gICAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgICAgIGNvbnN0IFtpZEJlZm9yZSwgaWRBZnRlcl0gPSBnZXRSZXNpemVIYW5kbGVQYW5lbElkcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxzQXJyYXkpO1xuICAgICAgaWYgKGlkQmVmb3JlID09IG51bGwgfHwgaWRBZnRlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICAgIH1cbiAgICAgIGxldCBjdXJyZW50TWluU2l6ZSA9IDA7XG4gICAgICBsZXQgY3VycmVudE1heFNpemUgPSAxMDA7XG4gICAgICBsZXQgdG90YWxNaW5TaXplID0gMDtcbiAgICAgIGxldCB0b3RhbE1heFNpemUgPSAwO1xuXG4gICAgICAvLyBBIHBhbmVsJ3MgZWZmZWN0aXZlIG1pbi9tYXggc2l6ZXMgYWxzbyBuZWVkIHRvIGFjY291bnQgZm9yIG90aGVyIHBhbmVsJ3Mgc2l6ZXMuXG4gICAgICBwYW5lbHNBcnJheS5mb3JFYWNoKHBhbmVsRGF0YSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBtYXhTaXplLFxuICAgICAgICAgIG1pblNpemVcbiAgICAgICAgfSA9IHBhbmVsRGF0YS5jdXJyZW50O1xuICAgICAgICBpZiAoaWQgPT09IGlkQmVmb3JlKSB7XG4gICAgICAgICAgY3VycmVudE1pblNpemUgPSBtaW5TaXplO1xuICAgICAgICAgIGN1cnJlbnRNYXhTaXplID0gbWF4U2l6ZSAhPSBudWxsID8gbWF4U2l6ZSA6IDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbE1pblNpemUgKz0gbWluU2l6ZTtcbiAgICAgICAgICB0b3RhbE1heFNpemUgKz0gbWF4U2l6ZSAhPSBudWxsID8gbWF4U2l6ZSA6IDEwMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBhcmlhVmFsdWVNYXggPSBNYXRoLm1pbihjdXJyZW50TWF4U2l6ZSwgMTAwIC0gdG90YWxNaW5TaXplKTtcbiAgICAgIGNvbnN0IGFyaWFWYWx1ZU1pbiA9IE1hdGgubWF4KGN1cnJlbnRNaW5TaXplLCAocGFuZWxzQXJyYXkubGVuZ3RoIC0gMSkgKiAxMDAgLSB0b3RhbE1heFNpemUpO1xuICAgICAgY29uc3QgZmxleEdyb3cgPSBnZXRGbGV4R3JvdyhwYW5lbHMsIGlkQmVmb3JlLCBzaXplcyk7XG4gICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1heFwiLCBcIlwiICsgTWF0aC5yb3VuZChhcmlhVmFsdWVNYXgpKTtcbiAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWluXCIsIFwiXCIgKyBNYXRoLnJvdW5kKGFyaWFWYWx1ZU1pbikpO1xuICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVub3dcIiwgXCJcIiArIE1hdGgucm91bmQocGFyc2VJbnQoZmxleEdyb3cpKSk7XG4gICAgICBjb25zdCBvbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFuZWxzQXJyYXkuZmluZEluZGV4KHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWQgPT09IGlkQmVmb3JlKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lbERhdGEgPSBwYW5lbHNBcnJheVtpbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHNpemUudG9QcmVjaXNpb24oUFJFQ0lTSU9OKSA8PSBwYW5lbERhdGEuY3VycmVudC5taW5TaXplLnRvUHJlY2lzaW9uKFBSRUNJU0lPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gd2lkdGggOiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IC0oZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIiA/IHdpZHRoIDogaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTaXplcyA9IGFkanVzdEJ5RGVsdGEoZXZlbnQsIGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LCBpZEJlZm9yZSwgaWRBZnRlciwgZGVsdGEsIHNpemVzLCBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZS5jdXJyZW50LCBudWxsKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzaXplcyAhPT0gbmV4dFNpemVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFNpemVzKG5leHRTaXplcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICBjb25zdCBwYW5lbEJlZm9yZSA9IGdldFBhbmVsKGlkQmVmb3JlKTtcbiAgICAgIGlmIChwYW5lbEJlZm9yZSAhPSBudWxsKSB7XG4gICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIHBhbmVsQmVmb3JlLmlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGhhbmRsZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWF4XCIpO1xuICAgICAgICBoYW5kbGUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS12YWx1ZW1pblwiKTtcbiAgICAgICAgaGFuZGxlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtdmFsdWVub3dcIik7XG4gICAgICAgIGhhbmRsZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgICBpZiAocGFuZWxCZWZvcmUgIT0gbnVsbCkge1xuICAgICAgICAgIGhhbmRsZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwRnVuY3Rpb25zLmZvckVhY2goY2xlYW51cEZ1bmN0aW9uID0+IGNsZWFudXBGdW5jdGlvbigpKTtcbiAgICB9O1xuICB9LCBbY29tbWl0dGVkVmFsdWVzUmVmLCBncm91cElkLCBwYW5lbHMsIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLCBzZXRTaXplcywgc2l6ZXNdKTtcbn1cbmZ1bmN0aW9uIHVzZVdpbmRvd1NwbGl0dGVyUmVzaXplSGFuZGxlckJlaGF2aW9yKHtcbiAgZGlzYWJsZWQsXG4gIGhhbmRsZUlkLFxuICByZXNpemVIYW5kbGVyXG59KSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHJlc2l6ZUhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVFbGVtZW50ID0gZ2V0UmVzaXplSGFuZGxlKGhhbmRsZUlkKTtcbiAgICBpZiAoaGFuZGxlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uS2V5RG93biA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlc2l6ZUhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiRjZcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0UmVzaXplSGFuZGxlSW5kZXgoaGFuZGxlSWQpO1xuICAgICAgICAgICAgYXNzZXJ0KGluZGV4ICE9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IGV2ZW50LnNoaWZ0S2V5ID8gaW5kZXggPiAwID8gaW5kZXggLSAxIDogaGFuZGxlcy5sZW5ndGggLSAxIDogaW5kZXggKyAxIDwgaGFuZGxlcy5sZW5ndGggPyBpbmRleCArIDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgbmV4dEhhbmRsZSA9IGhhbmRsZXNbbmV4dEluZGV4XTtcbiAgICAgICAgICAgIG5leHRIYW5kbGUuZm9jdXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGFuZGxlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgaGFuZGxlSWQsIHJlc2l6ZUhhbmRsZXJdKTtcbn1cblxuZnVuY3Rpb24gYXJlRXF1YWwoYXJyYXlBLCBhcnJheUIpIHtcbiAgaWYgKGFycmF5QS5sZW5ndGggIT09IGFycmF5Qi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5QS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoYXJyYXlBW2luZGV4XSAhPT0gYXJyYXlCW2luZGV4XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RHJhZ09mZnNldChldmVudCwgaGFuZGxlSWQsIGRpcmVjdGlvbiwgaW5pdGlhbE9mZnNldCA9IDAsIGluaXRpYWxIYW5kbGVFbGVtZW50UmVjdCA9IG51bGwpIHtcbiAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgbGV0IHBvaW50ZXJPZmZzZXQgPSAwO1xuICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgIHBvaW50ZXJPZmZzZXQgPSBpc0hvcml6b250YWwgPyBldmVudC5jbGllbnRYIDogZXZlbnQuY2xpZW50WTtcbiAgfSBlbHNlIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgY29uc3QgZmlyc3RUb3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgcG9pbnRlck9mZnNldCA9IGlzSG9yaXpvbnRhbCA/IGZpcnN0VG91Y2guc2NyZWVuWCA6IGZpcnN0VG91Y2guc2NyZWVuWTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBoYW5kbGVFbGVtZW50ID0gZ2V0UmVzaXplSGFuZGxlKGhhbmRsZUlkKTtcbiAgY29uc3QgcmVjdCA9IGluaXRpYWxIYW5kbGVFbGVtZW50UmVjdCB8fCBoYW5kbGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBlbGVtZW50T2Zmc2V0ID0gaXNIb3Jpem9udGFsID8gcmVjdC5sZWZ0IDogcmVjdC50b3A7XG4gIHJldHVybiBwb2ludGVyT2Zmc2V0IC0gZWxlbWVudE9mZnNldCAtIGluaXRpYWxPZmZzZXQ7XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L21vdmVtZW50WFxuZnVuY3Rpb24gZ2V0TW92ZW1lbnQoZXZlbnQsIGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbHNBcnJheSwgZGlyZWN0aW9uLCBwcmV2U2l6ZXMsIGluaXRpYWxEcmFnU3RhdGUpIHtcbiAgY29uc3Qge1xuICAgIGRyYWdPZmZzZXQgPSAwLFxuICAgIGRyYWdIYW5kbGVSZWN0LFxuICAgIHNpemVzOiBpbml0aWFsU2l6ZXNcbiAgfSA9IGluaXRpYWxEcmFnU3RhdGUgfHwge307XG5cbiAgLy8gSWYgd2UncmUgcmVzaXppbmcgYnkgbW91c2Ugb3IgdG91Y2gsIHVzZSB0aGUgaW5pdGlhbCBzaXplcyBhcyBhIGJhc2UuXG4gIC8vIFRoaXMgaGFzIHRoZSBiZW5lZml0IG9mIGNhdXNpbmcgZm9yY2UtY29sbGFwc2VkIHBhbmVscyB0byBzcHJpbmcgYmFjayBvcGVuIGlmIGRyYWcgaXMgcmV2ZXJzZWQuXG4gIGNvbnN0IGJhc2VTaXplcyA9IGluaXRpYWxTaXplcyB8fCBwcmV2U2l6ZXM7XG4gIGlmIChpc0tleURvd24oZXZlbnQpKSB7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgICBjb25zdCBncm91cEVsZW1lbnQgPSBnZXRQYW5lbEdyb3VwKGdyb3VwSWQpO1xuICAgIGNvbnN0IHJlY3QgPSBncm91cEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZ3JvdXBTaXplSW5QaXhlbHMgPSBpc0hvcml6b250YWwgPyByZWN0LndpZHRoIDogcmVjdC5oZWlnaHQ7XG4gICAgY29uc3QgZGVub21pbmF0b3IgPSBldmVudC5zaGlmdEtleSA/IDEwIDogMTAwO1xuICAgIGNvbnN0IGRlbHRhID0gZ3JvdXBTaXplSW5QaXhlbHMgLyBkZW5vbWluYXRvcjtcbiAgICBsZXQgbW92ZW1lbnQgPSAwO1xuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gMCA6IGRlbHRhO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyAtZGVsdGEgOiAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gZGVsdGEgOiAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gMCA6IC1kZWx0YTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgIG1vdmVtZW50ID0gZ3JvdXBTaXplSW5QaXhlbHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgbW92ZW1lbnQgPSAtZ3JvdXBTaXplSW5QaXhlbHM7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBQYW5lbCBiZWluZyByZXNpemVkIGlzIGNvbGxhcHNpYmxlLFxuICAgIC8vIHdlIG5lZWQgdG8gc3BlY2lhbCBjYXNlIHJlc2l6aW5nIGFyb3VuZCB0aGUgbWluU2l6ZSBib3VuZGFyeS5cbiAgICAvLyBJZiBjb250cmFjdGluZywgUGFuZWxzIHNob3VsZCBzaHJpbmsgdG8gdGhlaXIgbWluU2l6ZSBhbmQgdGhlbiBzbmFwIHRvIGZ1bGx5IGNvbGxhcHNlZC5cbiAgICAvLyBJZiBleHBhbmRpbmcgZnJvbSBjb2xsYXBzZWQsIHRoZXkgc2hvdWxkIHNuYXAgYmFjayB0byB0aGVpciBtaW5TaXplLlxuICAgIGNvbnN0IFtpZEJlZm9yZSwgaWRBZnRlcl0gPSBnZXRSZXNpemVIYW5kbGVQYW5lbElkcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxzQXJyYXkpO1xuICAgIGNvbnN0IHRhcmdldFBhbmVsSWQgPSBtb3ZlbWVudCA8IDAgPyBpZEJlZm9yZSA6IGlkQWZ0ZXI7XG4gICAgY29uc3QgdGFyZ2V0UGFuZWxJbmRleCA9IHBhbmVsc0FycmF5LmZpbmRJbmRleChwYW5lbCA9PiBwYW5lbC5jdXJyZW50LmlkID09PSB0YXJnZXRQYW5lbElkKTtcbiAgICBjb25zdCB0YXJnZXRQYW5lbCA9IHBhbmVsc0FycmF5W3RhcmdldFBhbmVsSW5kZXhdO1xuICAgIGlmICh0YXJnZXRQYW5lbC5jdXJyZW50LmNvbGxhcHNpYmxlKSB7XG4gICAgICBjb25zdCBiYXNlU2l6ZSA9IGJhc2VTaXplc1t0YXJnZXRQYW5lbEluZGV4XTtcbiAgICAgIGlmIChiYXNlU2l6ZSA9PT0gMCB8fCBiYXNlU2l6ZS50b1ByZWNpc2lvbihQUkVDSVNJT04pID09PSB0YXJnZXRQYW5lbC5jdXJyZW50Lm1pblNpemUudG9QcmVjaXNpb24oUFJFQ0lTSU9OKSkge1xuICAgICAgICBtb3ZlbWVudCA9IG1vdmVtZW50IDwgMCA/IC10YXJnZXRQYW5lbC5jdXJyZW50Lm1pblNpemUgKiBncm91cFNpemVJblBpeGVscyA6IHRhcmdldFBhbmVsLmN1cnJlbnQubWluU2l6ZSAqIGdyb3VwU2l6ZUluUGl4ZWxzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW92ZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldERyYWdPZmZzZXQoZXZlbnQsIGhhbmRsZUlkLCBkaXJlY3Rpb24sIGRyYWdPZmZzZXQsIGRyYWdIYW5kbGVSZWN0KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNLZXlEb3duKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSBcImtleWRvd25cIjtcbn1cbmZ1bmN0aW9uIGlzTW91c2VFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZS5zdGFydHNXaXRoKFwibW91c2VcIik7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcInRvdWNoXCIpO1xufVxuXG5sZXQgY3VycmVudFN0YXRlID0gbnVsbDtcbmxldCBlbGVtZW50ID0gbnVsbDtcbmZ1bmN0aW9uIGdldEN1cnNvclN0eWxlKHN0YXRlKSB7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgcmV0dXJuIFwiZXctcmVzaXplXCI7XG4gICAgY2FzZSBcImhvcml6b250YWwtbWF4XCI6XG4gICAgICByZXR1cm4gXCJ3LXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJob3Jpem9udGFsLW1pblwiOlxuICAgICAgcmV0dXJuIFwiZS1yZXNpemVcIjtcbiAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgIHJldHVybiBcIm5zLXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJ2ZXJ0aWNhbC1tYXhcIjpcbiAgICAgIHJldHVybiBcIm4tcmVzaXplXCI7XG4gICAgY2FzZSBcInZlcnRpY2FsLW1pblwiOlxuICAgICAgcmV0dXJuIFwicy1yZXNpemVcIjtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRHbG9iYWxDdXJzb3JTdHlsZSgpIHtcbiAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIGN1cnJlbnRTdGF0ZSA9IG51bGw7XG4gICAgZWxlbWVudCA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEdsb2JhbEN1cnNvclN0eWxlKHN0YXRlKSB7XG4gIGlmIChjdXJyZW50U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuICBjb25zdCBzdHlsZSA9IGdldEN1cnNvclN0eWxlKHN0YXRlKTtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbiAgZWxlbWVudC5pbm5lckhUTUwgPSBgKntjdXJzb3I6ICR7c3R5bGV9IWltcG9ydGFudDt9YDtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoY2FsbGJhY2ssIGR1cmF0aW9uTXMgPSAxMCkge1xuICBsZXQgdGltZW91dElkID0gbnVsbDtcbiAgbGV0IGNhbGxhYmxlID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAodGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICB9LCBkdXJhdGlvbk1zKTtcbiAgfTtcbiAgcmV0dXJuIGNhbGxhYmxlO1xufVxuXG4vLyBOb3RlIHRoYXQgUGFuZWwgaWRzIG1pZ2h0IGJlIHVzZXItcHJvdmlkZWQgKHN0YWJsZSkgb3IgdXNlSWQgZ2VuZXJhdGVkIChub24tZGV0ZXJtaW5pc3RpYylcbi8vIHNvIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHBhcnQgb2YgdGhlIHNlcmlhbGl6YXRpb24ga2V5LlxuLy8gVXNpbmcgYW4gYXR0cmlidXRlIGxpa2UgbWluU2l6ZSBpbnN0ZWFkIHNob3VsZCB3b3JrIHdlbGwgZW5vdWdoLlxuLy8gUHJlLXNvcnRpbmcgYnkgbWluU2l6ZSBhbGxvd3MgcmVtZW1iZXJpbmcgbGF5b3V0cyBldmVuIGlmIHBhbmVscyBhcmUgcmUtb3JkZXJlZC9kcmFnZ2VkLlxuZnVuY3Rpb24gZ2V0U2VyaWFsaXphdGlvbktleShwYW5lbHMpIHtcbiAgcmV0dXJuIHBhbmVscy5tYXAocGFuZWwgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1pblNpemUsXG4gICAgICBvcmRlclxuICAgIH0gPSBwYW5lbC5jdXJyZW50O1xuICAgIHJldHVybiBvcmRlciA/IGAke29yZGVyfToke21pblNpemV9YCA6IGAke21pblNpemV9YDtcbiAgfSkuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKS5qb2luKFwiLFwiKTtcbn1cbmZ1bmN0aW9uIGxvYWRTZXJpYWxpemVkUGFuZWxHcm91cFN0YXRlKGF1dG9TYXZlSWQsIHN0b3JhZ2UpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gc3RvcmFnZS5nZXRJdGVtKGBQYW5lbEdyb3VwOnNpemVzOiR7YXV0b1NhdmVJZH1gKTtcbiAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzZXJpYWxpemVkKTtcbiAgICAgIGlmICh0eXBlb2YgcGFyc2VkID09PSBcIm9iamVjdFwiICYmIHBhcnNlZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzYXZlUGFuZWxHcm91cExheW91dChhdXRvU2F2ZUlkLCBwYW5lbHMsIHNpemVzLCBzdG9yYWdlKSB7XG4gIGNvbnN0IGtleSA9IGdldFNlcmlhbGl6YXRpb25LZXkocGFuZWxzKTtcbiAgY29uc3Qgc3RhdGUgPSBsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZShhdXRvU2F2ZUlkLCBzdG9yYWdlKSB8fCB7fTtcbiAgc3RhdGVba2V5XSA9IHNpemVzO1xuICB0cnkge1xuICAgIHN0b3JhZ2Uuc2V0SXRlbShgUGFuZWxHcm91cDpzaXplczoke2F1dG9TYXZlSWR9YCwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxufVxuXG5jb25zdCBkZWJvdW5jZU1hcCA9IHt9O1xuXG4vLyBQYW5lbEdyb3VwIG1pZ2h0IGJlIHJlbmRlcmluZyBpbiBhIHNlcnZlci1zaWRlIGVudmlyb25tZW50IHdoZXJlIGxvY2FsU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlXG4vLyBvciBvbiBhIGJyb3dzZXIgd2l0aCBjb29raWVzL3N0b3JhZ2UgZGlzYWJsZWQuXG4vLyBJbiBlaXRoZXIgY2FzZSwgdGhpcyBmdW5jdGlvbiBhdm9pZHMgYWNjZXNzaW5nIGxvY2FsU3RvcmFnZSB1bnRpbCBuZWVkZWQsXG4vLyBhbmQgYXZvaWRzIHRocm93aW5nIHVzZXItdmlzaWJsZSBlcnJvcnMuXG5mdW5jdGlvbiBpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2Uoc3RvcmFnZU9iamVjdCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAvLyBCeXBhc3MgdGhpcyBjaGVjayBmb3IgZnV0dXJlIGNhbGxzXG4gICAgICBzdG9yYWdlT2JqZWN0LmdldEl0ZW0gPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICAgICAgfTtcbiAgICAgIHN0b3JhZ2VPYmplY3Quc2V0SXRlbSA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2NhbFN0b3JhZ2Ugbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICBzdG9yYWdlT2JqZWN0LmdldEl0ZW0gPSAoKSA9PiBudWxsO1xuICAgIHN0b3JhZ2VPYmplY3Quc2V0SXRlbSA9ICgpID0+IHt9O1xuICB9XG59XG5jb25zdCBkZWZhdWx0U3RvcmFnZSA9IHtcbiAgZ2V0SXRlbTogbmFtZSA9PiB7XG4gICAgaW5pdGlhbGl6ZURlZmF1bHRTdG9yYWdlKGRlZmF1bHRTdG9yYWdlKTtcbiAgICByZXR1cm4gZGVmYXVsdFN0b3JhZ2UuZ2V0SXRlbShuYW1lKTtcbiAgfSxcbiAgc2V0SXRlbTogKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgaW5pdGlhbGl6ZURlZmF1bHRTdG9yYWdlKGRlZmF1bHRTdG9yYWdlKTtcbiAgICBkZWZhdWx0U3RvcmFnZS5zZXRJdGVtKG5hbWUsIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gSW5pdGlhbCBkcmFnIHN0YXRlIHNlcnZlcyBhIGZldyBwdXJwb3Nlczpcbi8vICogZHJhZ09mZnNldDpcbi8vICAgUmVzaXplIGlzIGNhbGN1bGF0ZWQgYnkgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgcG9pbnRlciBldmVudCBhbmQgdGhlIHJlc2l6ZSBoYW5kbGUgYmVpbmcgXCJkcmFnZ2VkXCJcbi8vICAgVGhpcyB2YWx1ZSBhY2NvdW50cyBmb3IgdGhlIGluaXRpYWwgb2Zmc2V0IHdoZW4gdGhlIHRvdWNoL2NsaWNrIHN0YXJ0cywgc28gdGhlIGhhbmRsZSBkb2Vzbid0IGFwcGVhciB0byBcImp1bXBcIlxuLy8gKiBkcmFnSGFuZGxlUmVjdCwgc2l6ZXM6XG4vLyAgIFdoZW4gcmVzaXppbmcgaXMgZG9uZSB2aWEgbW91c2UvdG91Y2ggZXZlbnTigJMgc29tZSBpbml0aWFsIHN0YXRlIGlzIHN0b3JlZFxuLy8gICBzbyB0aGF0IGFueSBwYW5lbHMgdGhhdCBjb250cmFjdCB3aWxsIGFsc28gZXhwYW5kIGlmIGRyYWcgZGlyZWN0aW9uIGlzIHJldmVyc2VkLlxuZnVuY3Rpb24gUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYoe1xuICBhdXRvU2F2ZUlkLFxuICBjaGlsZHJlbiA9IG51bGwsXG4gIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzID0gXCJcIixcbiAgZGlyZWN0aW9uLFxuICBkaXNhYmxlUG9pbnRlckV2ZW50c0R1cmluZ1Jlc2l6ZSA9IGZhbHNlLFxuICBmb3J3YXJkZWRSZWYsXG4gIGlkOiBpZEZyb21Qcm9wcyA9IG51bGwsXG4gIG9uTGF5b3V0LFxuICBzdG9yYWdlID0gZGVmYXVsdFN0b3JhZ2UsXG4gIHN0eWxlOiBzdHlsZUZyb21Qcm9wcyA9IHt9LFxuICB0YWdOYW1lOiBUeXBlID0gXCJkaXZcIixcbiAgdW5pdHMgPSBcInBlcmNlbnRhZ2VzXCJcbn0pIHtcbiAgY29uc3QgZ3JvdXBJZCA9IHVzZVVuaXF1ZUlkKGlkRnJvbVByb3BzKTtcbiAgY29uc3QgW2FjdGl2ZUhhbmRsZUlkLCBzZXRBY3RpdmVIYW5kbGVJZF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3BhbmVscywgc2V0UGFuZWxzXSA9IHVzZVN0YXRlKG5ldyBNYXAoKSk7XG5cbiAgLy8gV2hlbiByZXNpemluZyBpcyBkb25lIHZpYSBtb3VzZS90b3VjaCBldmVudOKAk1xuICAvLyBXZSBzdG9yZSB0aGUgaW5pdGlhbCBQYW5lbCBzaXplcyBpbiB0aGlzIHJlZiwgYW5kIGFwcGx5IG1vdmUgZGVsdGFzIHRvIHRoZW0gaW5zdGVhZCBvZiB0byB0aGUgY3VycmVudCBzaXplcy5cbiAgLy8gVGhpcyBoYXMgdGhlIGJlbmVmaXQgb2YgY2F1c2luZyBmb3JjZS1jb2xsYXBzZWQgcGFuZWxzIHRvIHNwcmluZyBiYWNrIG9wZW4gaWYgZHJhZyBpcyByZXZlcnNlZC5cbiAgY29uc3QgaW5pdGlhbERyYWdTdGF0ZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZGV2V2FybmluZ3NSZWYgPSB1c2VSZWYoe1xuICAgIGRpZExvZ0RlZmF1bHRTaXplV2FybmluZzogZmFsc2UsXG4gICAgZGlkTG9nSWRBbmRPcmRlcldhcm5pbmc6IGZhbHNlLFxuICAgIGRpZExvZ0ludmFsaWRMYXlvdXRXYXJuaW5nOiBmYWxzZSxcbiAgICBwcmV2UGFuZWxJZHM6IFtdXG4gIH0pO1xuXG4gIC8vIFVzZSBhIHJlZiB0byBndWFyZCBhZ2FpbnN0IHVzZXJzIHBhc3NpbmcgaW5saW5lIHByb3BzXG4gIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZih7XG4gICAgb25MYXlvdXRcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25MYXlvdXQgPSBvbkxheW91dDtcbiAgfSk7XG4gIGNvbnN0IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYgPSB1c2VSZWYoe30pO1xuXG4gIC8vIDAtMSB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSByZWxhdGl2ZSBzaXplIG9mIGVhY2ggcGFuZWwuXG4gIGNvbnN0IFtzaXplcywgc2V0U2l6ZXNdID0gdXNlU3RhdGUoW10pO1xuXG4gIC8vIFVzZWQgdG8gc3VwcG9ydCBpbXBlcmF0aXZlIGNvbGxhcHNlL2V4cGFuZCBBUEkuXG4gIGNvbnN0IHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIGNvbnN0IHByZXZEZWx0YVJlZiA9IHVzZVJlZigwKTtcblxuICAvLyBTdG9yZSBjb21taXR0ZWQgdmFsdWVzIHRvIGF2b2lkIHVubmVjZXNzYXJpbHkgcmUtcnVubmluZyBtZW1vaXphdGlvbi9lZmZlY3RzIGZ1bmN0aW9ucy5cbiAgY29uc3QgY29tbWl0dGVkVmFsdWVzUmVmID0gdXNlUmVmKHtcbiAgICBkaXJlY3Rpb24sXG4gICAgaWQ6IGdyb3VwSWQsXG4gICAgcGFuZWxzLFxuICAgIHNpemVzLFxuICAgIHVuaXRzXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4gKHtcbiAgICBnZXRJZDogKCkgPT4gZ3JvdXBJZCxcbiAgICBnZXRMYXlvdXQ6IHVuaXRzRnJvbVBhcmFtcyA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpemVzLFxuICAgICAgICB1bml0czogdW5pdHNGcm9tUHJvcHNcbiAgICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHVuaXRzID0gdW5pdHNGcm9tUGFyYW1zID8/IHVuaXRzRnJvbVByb3BzO1xuICAgICAgaWYgKHVuaXRzID09PSBcInBpeGVsc1wiKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwU2l6ZVBpeGVscyA9IGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyhncm91cElkKTtcbiAgICAgICAgcmV0dXJuIHNpemVzLm1hcChzaXplID0+IHNpemUgLyAxMDAgKiBncm91cFNpemVQaXhlbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpemVzO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0TGF5b3V0OiAoc2l6ZXMsIHVuaXRzRnJvbVBhcmFtcykgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpZDogZ3JvdXBJZCxcbiAgICAgICAgcGFuZWxzLFxuICAgICAgICBzaXplczogcHJldlNpemVzLFxuICAgICAgICB1bml0c1xuICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCh1bml0c0Zyb21QYXJhbXMgfHwgdW5pdHMpID09PSBcInBpeGVsc1wiKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwU2l6ZVBpeGVscyA9IGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyhncm91cElkKTtcbiAgICAgICAgc2l6ZXMgPSBzaXplcy5tYXAoc2l6ZSA9PiBzaXplIC8gZ3JvdXBTaXplUGl4ZWxzICogMTAwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXAgPSBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgICAgIGNvbnN0IG5leHRTaXplcyA9IHZhbGlkYXRlUGFuZWxHcm91cExheW91dCh7XG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIHBhbmVscyxcbiAgICAgICAgbmV4dFNpemVzOiBzaXplcyxcbiAgICAgICAgcHJldlNpemVzLFxuICAgICAgICB1bml0c1xuICAgICAgfSk7XG4gICAgICBpZiAoIWFyZUVxdWFsKHByZXZTaXplcywgbmV4dFNpemVzKSkge1xuICAgICAgICBzZXRTaXplcyhuZXh0U2l6ZXMpO1xuICAgICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxzQXJyYXksIG5leHRTaXplcywgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgW2dyb3VwSWRdKTtcbiAgdXNlV2luZG93U3BsaXR0ZXJQYW5lbEdyb3VwQmVoYXZpb3Ioe1xuICAgIGNvbW1pdHRlZFZhbHVlc1JlZixcbiAgICBncm91cElkLFxuICAgIHBhbmVscyxcbiAgICBzZXRTaXplcyxcbiAgICBzaXplcyxcbiAgICBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVxuICB9KTtcblxuICAvLyBOb3RpZnkgZXh0ZXJuYWwgY29kZSB3aGVuIHNpemVzIGhhdmUgY2hhbmdlZC5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvbkxheW91dFxuICAgIH0gPSBjYWxsYmFja3NSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbHMsXG4gICAgICBzaXplc1xuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcblxuICAgIC8vIERvbid0IGNvbW1pdCBsYXlvdXQgdW50aWwgYWxsIHBhbmVscyBoYXZlIHJlZ2lzdGVyZWQgYW5kIHJlLXJlbmRlcmVkIHdpdGggdGhlaXIgYWN0dWFsIHNpemVzLlxuICAgIGlmIChzaXplcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgb25MYXlvdXQoc2l6ZXMpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudDtcblxuICAgICAgLy8gV2hlbiBwb3NzaWJsZSwgd2Ugbm90aWZ5IGJlZm9yZSB0aGUgbmV4dCByZW5kZXIgc28gdGhhdCByZW5kZXJpbmcgd29yayBjYW4gYmUgYmF0Y2hlZCB0b2dldGhlci5cbiAgICAgIC8vIFNvbWUgY2FzZXMgYXJlIGRpZmZpY3VsdCB0byBkZXRlY3QgdGhvdWdoLFxuICAgICAgLy8gZm9yIGV4YW1wbGXigJMgcGFuZWxzIHRoYXQgYXJlIGNvbmRpdGlvbmFsbHkgcmVuZGVyZWQgY2FuIGFmZmVjdCB0aGUgc2l6ZSBvZiBuZWlnaGJvcmluZyBwYW5lbHMuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSBiZXN0IHdlIGNhbiBkbyBpcyBub3RpZnkgb24gY29tbWl0LlxuICAgICAgLy8gVGhlIGNhbGxQYW5lbENhbGxiYWNrcygpIHVzZXMgaXRzIG93biBtZW1vaXphdGlvbiB0byBhdm9pZCBub3RpZnlpbmcgcGFuZWxzIHR3aWNlIGluIHRoZXNlIGNhc2VzLlxuICAgICAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxzQXJyYXksIHNpemVzLCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwKTtcbiAgICB9XG4gIH0sIFtzaXplc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHRoaXMgcGFuZWwgaGFzIGJlZW4gY29uZmlndXJlZCB0byBwZXJzaXN0IHNpemluZyBpbmZvcm1hdGlvbiwgc2F2ZSBzaXplcyB0byBsb2NhbCBzdG9yYWdlLlxuICAgIGlmIChhdXRvU2F2ZUlkKSB7XG4gICAgICBpZiAoc2l6ZXMubGVuZ3RoID09PSAwIHx8IHNpemVzLmxlbmd0aCAhPT0gcGFuZWxzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG5cbiAgICAgIC8vIExpbWl0IHRoZSBmcmVxdWVuY3kgb2YgbG9jYWxTdG9yYWdlIHVwZGF0ZXMuXG4gICAgICBpZiAoIWRlYm91bmNlTWFwW2F1dG9TYXZlSWRdKSB7XG4gICAgICAgIGRlYm91bmNlTWFwW2F1dG9TYXZlSWRdID0gZGVib3VuY2Uoc2F2ZVBhbmVsR3JvdXBMYXlvdXQsIDEwMCk7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZU1hcFthdXRvU2F2ZUlkXShhdXRvU2F2ZUlkLCBwYW5lbHNBcnJheSwgc2l6ZXMsIHN0b3JhZ2UpO1xuICAgIH1cbiAgICB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nLFxuICAgICAgICBwcmV2UGFuZWxJZHNcbiAgICAgIH0gPSBkZXZXYXJuaW5nc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFkaWRMb2dJZEFuZE9yZGVyV2FybmluZykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGFuZWxzXG4gICAgICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgICAgY29uc3QgcGFuZWxJZHMgPSBBcnJheS5mcm9tKHBhbmVscy5rZXlzKCkpO1xuICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LnByZXZQYW5lbElkcyA9IHBhbmVsSWRzO1xuICAgICAgICBjb25zdCBwYW5lbHNIYXZlQ2hhbmdlZCA9IHByZXZQYW5lbElkcy5sZW5ndGggPiAwICYmICFhcmVFcXVhbChwcmV2UGFuZWxJZHMsIHBhbmVsSWRzKTtcbiAgICAgICAgaWYgKHBhbmVsc0hhdmVDaGFuZ2VkKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmZyb20ocGFuZWxzLnZhbHVlcygpKS5maW5kKHBhbmVsID0+IHBhbmVsLmN1cnJlbnQuaWRXYXNBdXRvR2VuZXJhdGVkIHx8IHBhbmVsLmN1cnJlbnQub3JkZXIgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIGRldldhcm5pbmdzUmVmLmN1cnJlbnQuZGlkTG9nSWRBbmRPcmRlcldhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBQYW5lbCBpZCBhbmQgb3JkZXIgcHJvcHMgcmVjb21tZW5kZWQgd2hlbiBwYW5lbHMgYXJlIGR5bmFtaWNhbGx5IHJlbmRlcmVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBbYXV0b1NhdmVJZCwgcGFuZWxzLCBzaXplcywgc3RvcmFnZV0pO1xuICBjb25zdCBnZXRQYW5lbFNpemUgPSB1c2VDYWxsYmFjaygoaWQsIHVuaXRzRnJvbVBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVscyxcbiAgICAgIHVuaXRzOiB1bml0c0Zyb21Qcm9wc1xuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYW5lbHNBcnJheSA9IHBhbmVsc01hcFRvU29ydGVkQXJyYXkocGFuZWxzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhbmVsc0FycmF5LmZpbmRJbmRleChwYW5lbCA9PiBwYW5lbC5jdXJyZW50LmlkID09PSBpZCk7XG4gICAgY29uc3Qgc2l6ZSA9IHNpemVzW2luZGV4XTtcbiAgICBjb25zdCB1bml0cyA9IHVuaXRzRnJvbVBhcmFtcyA/PyB1bml0c0Zyb21Qcm9wcztcbiAgICBpZiAodW5pdHMgPT09IFwicGl4ZWxzXCIpIHtcbiAgICAgIGNvbnN0IGdyb3VwU2l6ZVBpeGVscyA9IGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyhncm91cElkKTtcbiAgICAgIHJldHVybiBzaXplIC8gMTAwICogZ3JvdXBTaXplUGl4ZWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH0sIFtncm91cElkLCBzaXplc10pO1xuICBjb25zdCBnZXRQYW5lbFN0eWxlID0gdXNlQ2FsbGJhY2soKGlkLCBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsc1xuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcblxuICAgIC8vIEJlZm9yZSBtb3VudGluZywgUGFuZWxzIHdpbGwgbm90IHlldCBoYXZlIHJlZ2lzdGVyZWQgdGhlbXNlbHZlcy5cbiAgICAvLyBUaGlzIGluY2x1ZGVzIHNlcnZlciByZW5kZXJpbmcuXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgYmVzdCB3ZSBjYW4gZG8gaXMgcmVuZGVyIGV2ZXJ5dGhpbmcgd2l0aCB0aGUgc2FtZSBzaXplLlxuICAgIGlmIChwYW5lbHMuc2l6ZSA9PT0gMCkge1xuICAgICAge1xuICAgICAgICBpZiAoIWRldldhcm5pbmdzUmVmLmN1cnJlbnQuZGlkTG9nRGVmYXVsdFNpemVXYXJuaW5nKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRTaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIGRldldhcm5pbmdzUmVmLmN1cnJlbnQuZGlkTG9nRGVmYXVsdFNpemVXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV0FSTklORzogUGFuZWwgZGVmYXVsdFNpemUgcHJvcCByZWNvbW1lbmRlZCB0byBhdm9pZCBsYXlvdXQgc2hpZnQgYWZ0ZXIgc2VydmVyIHJlbmRlcmluZ2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmxleEJhc2lzOiAwLFxuICAgICAgICBmbGV4R3JvdzogZGVmYXVsdFNpemUgIT0gbnVsbCA/IGRlZmF1bHRTaXplIDogdW5kZWZpbmVkLFxuICAgICAgICBmbGV4U2hyaW5rOiAxLFxuICAgICAgICAvLyBXaXRob3V0IHRoaXMsIFBhbmVsIHNpemVzIG1heSBiZSB1bmludGVudGlvbmFsbHkgb3ZlcnJpZGRlbiBieSB0aGVpciBjb250ZW50LlxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZmxleEdyb3cgPSBnZXRGbGV4R3JvdyhwYW5lbHMsIGlkLCBzaXplcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZsZXhCYXNpczogMCxcbiAgICAgIGZsZXhHcm93LFxuICAgICAgZmxleFNocmluazogMSxcbiAgICAgIC8vIFdpdGhvdXQgdGhpcywgUGFuZWwgc2l6ZXMgbWF5IGJlIHVuaW50ZW50aW9uYWxseSBvdmVycmlkZGVuIGJ5IHRoZWlyIGNvbnRlbnQuXG4gICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgIC8vIERpc2FibGUgcG9pbnRlciBldmVudHMgaW5zaWRlIG9mIGEgcGFuZWwgZHVyaW5nIHJlc2l6ZS5cbiAgICAgIC8vIFRoaXMgYXZvaWQgZWRnZSBjYXNlcyBsaWtlIG5lc3RlZCBpZnJhbWVzLlxuICAgICAgcG9pbnRlckV2ZW50czogZGlzYWJsZVBvaW50ZXJFdmVudHNEdXJpbmdSZXNpemUgJiYgYWN0aXZlSGFuZGxlSWQgIT09IG51bGwgPyBcIm5vbmVcIiA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH0sIFthY3RpdmVIYW5kbGVJZCwgZGlzYWJsZVBvaW50ZXJFdmVudHNEdXJpbmdSZXNpemUsIHNpemVzXSk7XG4gIGNvbnN0IHJlZ2lzdGVyUGFuZWwgPSB1c2VDYWxsYmFjaygoaWQsIHBhbmVsUmVmKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdW5pdHNcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgdmFsaWRhdGVQYW5lbFByb3BzKHVuaXRzLCBwYW5lbFJlZik7XG4gICAgc2V0UGFuZWxzKHByZXZQYW5lbHMgPT4ge1xuICAgICAgaWYgKHByZXZQYW5lbHMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gcHJldlBhbmVscztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRQYW5lbHMgPSBuZXcgTWFwKHByZXZQYW5lbHMpO1xuICAgICAgbmV4dFBhbmVscy5zZXQoaWQsIHBhbmVsUmVmKTtcbiAgICAgIHJldHVybiBuZXh0UGFuZWxzO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyUmVzaXplSGFuZGxlID0gdXNlQ2FsbGJhY2soaGFuZGxlSWQgPT4ge1xuICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHBhbmVscyxcbiAgICAgICAgc2l6ZXM6IHByZXZTaXplc1xuICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgcGFuZWxzQXJyYXkgPSBwYW5lbHNNYXBUb1NvcnRlZEFycmF5KHBhbmVscyk7XG4gICAgICBjb25zdCBbaWRCZWZvcmUsIGlkQWZ0ZXJdID0gZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMoZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsc0FycmF5KTtcbiAgICAgIGlmIChpZEJlZm9yZSA9PSBudWxsIHx8IGlkQWZ0ZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgbW92ZW1lbnQgPSBnZXRNb3ZlbWVudChldmVudCwgZ3JvdXBJZCwgaGFuZGxlSWQsIHBhbmVsc0FycmF5LCBkaXJlY3Rpb24sIHByZXZTaXplcywgaW5pdGlhbERyYWdTdGF0ZVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChtb3ZlbWVudCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cEVsZW1lbnQgPSBnZXRQYW5lbEdyb3VwKGdyb3VwSWQpO1xuICAgICAgY29uc3QgcmVjdCA9IGdyb3VwRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG5cbiAgICAgIC8vIFN1cHBvcnQgUlRMIGxheW91dHNcbiAgICAgIGlmIChkb2N1bWVudC5kaXIgPT09IFwicnRsXCIgJiYgaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1vdmVtZW50ID0gLW1vdmVtZW50O1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IGlzSG9yaXpvbnRhbCA/IHJlY3Qud2lkdGggOiByZWN0LmhlaWdodDtcbiAgICAgIGNvbnN0IGRlbHRhID0gbW92ZW1lbnQgLyBzaXplICogMTAwO1xuXG4gICAgICAvLyBJZiBhIHZhbGlkYXRlTGF5b3V0IG1ldGhvZCBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgLy8gaXQncyBpbXBvcnRhbnQgdG8gdXNlIGl0IGJlZm9yZSB1cGRhdGluZyB0aGUgbW91c2UgY3Vyc29yXG4gICAgICBjb25zdCBuZXh0U2l6ZXMgPSBhZGp1c3RCeURlbHRhKGV2ZW50LCBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudCwgaWRCZWZvcmUsIGlkQWZ0ZXIsIGRlbHRhLCBwcmV2U2l6ZXMsIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLmN1cnJlbnQsIGluaXRpYWxEcmFnU3RhdGVSZWYuY3VycmVudCk7XG4gICAgICBjb25zdCBzaXplc0NoYW5nZWQgPSAhYXJlRXF1YWwocHJldlNpemVzLCBuZXh0U2l6ZXMpO1xuXG4gICAgICAvLyBEb24ndCB1cGRhdGUgY3Vyc29yIGZvciByZXNpemVzIHRyaWdnZXJlZCBieSBrZXlib2FyZCBpbnRlcmFjdGlvbnMuXG4gICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSB8fCBpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIC8vIFdhdGNoIGZvciBtdWx0aXBsZSBzdWJzZXF1ZW50IGRlbHRhczsgdGhpcyBtaWdodCBvY2N1ciBmb3IgdGlueSBjdXJzb3IgbW92ZW1lbnRzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIFBhbmVsIHNpemVzIG1pZ2h0IG5vdCBjaGFuZ2XigJNcbiAgICAgICAgLy8gYnV0IHVwZGF0aW5nIGN1cnNvciBpbiB0aGlzIHNjZW5hcmlvIHdvdWxkIGNhdXNlIGEgZmxpY2tlci5cbiAgICAgICAgaWYgKHByZXZEZWx0YVJlZi5jdXJyZW50ICE9IGRlbHRhKSB7XG4gICAgICAgICAgaWYgKCFzaXplc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwb2ludGVyIGhhcyBtb3ZlZCB0b28gZmFyIHRvIHJlc2l6ZSB0aGUgcGFuZWwgYW55IGZ1cnRoZXIsXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGN1cnNvciBzdHlsZSBmb3IgYSB2aXN1YWwgY2x1ZS5cbiAgICAgICAgICAgIC8vIFRoaXMgbWltaWNzIFZTIENvZGUgYmVoYXZpb3IuXG5cbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgc2V0R2xvYmFsQ3Vyc29yU3R5bGUobW92ZW1lbnQgPCAwID8gXCJob3Jpem9udGFsLW1pblwiIDogXCJob3Jpem9udGFsLW1heFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldEdsb2JhbEN1cnNvclN0eWxlKG1vdmVtZW50IDwgMCA/IFwidmVydGljYWwtbWluXCIgOiBcInZlcnRpY2FsLW1heFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGN1cnNvciBzdHlsZSB0byB0aGUgdGhlIG5vcm1hbCByZXNpemUgY3Vyc29yLlxuICAgICAgICAgICAgc2V0R2xvYmFsQ3Vyc29yU3R5bGUoaXNIb3Jpem9udGFsID8gXCJob3Jpem9udGFsXCIgOiBcInZlcnRpY2FsXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNpemVzQ2hhbmdlZCkge1xuICAgICAgICBjb25zdCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwID0gcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50O1xuXG4gICAgICAgIC8vIEl0J3Mgb2theSB0byBieXBhc3MgaW4gdGhpcyBjYXNlIGJlY2F1c2Ugd2UgYWxyZWFkeSB2YWxpZGF0ZWQgYWJvdmVcbiAgICAgICAgc2V0U2l6ZXMobmV4dFNpemVzKTtcblxuICAgICAgICAvLyBJZiByZXNpemUgY2hhbmdlIGhhbmRsZXJzIGhhdmUgYmVlbiBkZWNsYXJlZCwgdGhpcyBpcyB0aGUgdGltZSB0byBjYWxsIHRoZW0uXG4gICAgICAgIC8vIFRyaWdnZXIgdXNlciBjYWxsYmFja3MgYWZ0ZXIgdXBkYXRpbmcgc3RhdGUsIHNvIHRoYXQgdXNlciBjb2RlIGNhbiBvdmVycmlkZSB0aGUgc2l6ZXMuXG4gICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgbmV4dFNpemVzLCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwKTtcbiAgICAgIH1cbiAgICAgIHByZXZEZWx0YVJlZi5jdXJyZW50ID0gZGVsdGE7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzaXplSGFuZGxlcjtcbiAgfSwgW2dyb3VwSWRdKTtcbiAgY29uc3QgdW5yZWdpc3RlclBhbmVsID0gdXNlQ2FsbGJhY2soaWQgPT4ge1xuICAgIHNldFBhbmVscyhwcmV2UGFuZWxzID0+IHtcbiAgICAgIGlmICghcHJldlBhbmVscy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybiBwcmV2UGFuZWxzO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dFBhbmVscyA9IG5ldyBNYXAocHJldlBhbmVscyk7XG4gICAgICBuZXh0UGFuZWxzLmRlbGV0ZShpZCk7XG4gICAgICByZXR1cm4gbmV4dFBhbmVscztcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCBjb2xsYXBzZVBhbmVsID0gdXNlQ2FsbGJhY2soaWQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVscyxcbiAgICAgIHNpemVzOiBwcmV2U2l6ZXNcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcGFuZWwgPSBwYW5lbHMuZ2V0KGlkKTtcbiAgICBpZiAocGFuZWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplLFxuICAgICAgY29sbGFwc2libGVcbiAgICB9ID0gcGFuZWwuY3VycmVudDtcbiAgICBpZiAoIWNvbGxhcHNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICAgIGNvbnN0IGluZGV4ID0gcGFuZWxzQXJyYXkuaW5kZXhPZihwYW5lbCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHByZXZTaXplc1tpbmRleF07XG4gICAgaWYgKGN1cnJlbnRTaXplID09PSBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAvLyBQYW5lbCBpcyBhbHJlYWR5IGNvbGxhcHNlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UuY3VycmVudC5zZXQoaWQsIGN1cnJlbnRTaXplKTtcbiAgICBjb25zdCBbaWRCZWZvcmUsIGlkQWZ0ZXJdID0gZ2V0QmVmb3JlQW5kQWZ0ZXJJZHMoaWQsIHBhbmVsc0FycmF5KTtcbiAgICBpZiAoaWRCZWZvcmUgPT0gbnVsbCB8fCBpZEFmdGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNMYXN0UGFuZWwgPSBpbmRleCA9PT0gcGFuZWxzQXJyYXkubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBkZWx0YSA9IGlzTGFzdFBhbmVsID8gY3VycmVudFNpemUgOiBjb2xsYXBzZWRTaXplIC0gY3VycmVudFNpemU7XG4gICAgY29uc3QgbmV4dFNpemVzID0gYWRqdXN0QnlEZWx0YShudWxsLCBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudCwgaWRCZWZvcmUsIGlkQWZ0ZXIsIGRlbHRhLCBwcmV2U2l6ZXMsIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLmN1cnJlbnQsIG51bGwpO1xuICAgIGlmIChwcmV2U2l6ZXMgIT09IG5leHRTaXplcykge1xuICAgICAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudDtcbiAgICAgIHNldFNpemVzKG5leHRTaXplcyk7XG5cbiAgICAgIC8vIElmIHJlc2l6ZSBjaGFuZ2UgaGFuZGxlcnMgaGF2ZSBiZWVuIGRlY2xhcmVkLCB0aGlzIGlzIHRoZSB0aW1lIHRvIGNhbGwgdGhlbS5cbiAgICAgIC8vIFRyaWdnZXIgdXNlciBjYWxsYmFja3MgYWZ0ZXIgdXBkYXRpbmcgc3RhdGUsIHNvIHRoYXQgdXNlciBjb2RlIGNhbiBvdmVycmlkZSB0aGUgc2l6ZXMuXG4gICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxzQXJyYXksIG5leHRTaXplcywgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IGV4cGFuZFBhbmVsID0gdXNlQ2FsbGJhY2soaWQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVscyxcbiAgICAgIHNpemVzOiBwcmV2U2l6ZXNcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcGFuZWwgPSBwYW5lbHMuZ2V0KGlkKTtcbiAgICBpZiAocGFuZWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplLFxuICAgICAgbWluU2l6ZVxuICAgIH0gPSBwYW5lbC5jdXJyZW50O1xuICAgIGNvbnN0IHNpemVCZWZvcmVDb2xsYXBzZSA9IHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLmN1cnJlbnQuZ2V0KGlkKSB8fCBtaW5TaXplO1xuICAgIGlmICghc2l6ZUJlZm9yZUNvbGxhcHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICAgIGNvbnN0IGluZGV4ID0gcGFuZWxzQXJyYXkuaW5kZXhPZihwYW5lbCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHByZXZTaXplc1tpbmRleF07XG4gICAgaWYgKGN1cnJlbnRTaXplICE9PSBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAvLyBQYW5lbCBpcyBhbHJlYWR5IGV4cGFuZGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbaWRCZWZvcmUsIGlkQWZ0ZXJdID0gZ2V0QmVmb3JlQW5kQWZ0ZXJJZHMoaWQsIHBhbmVsc0FycmF5KTtcbiAgICBpZiAoaWRCZWZvcmUgPT0gbnVsbCB8fCBpZEFmdGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNMYXN0UGFuZWwgPSBpbmRleCA9PT0gcGFuZWxzQXJyYXkubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBkZWx0YSA9IGlzTGFzdFBhbmVsID8gY29sbGFwc2VkU2l6ZSAtIHNpemVCZWZvcmVDb2xsYXBzZSA6IHNpemVCZWZvcmVDb2xsYXBzZTtcbiAgICBjb25zdCBuZXh0U2l6ZXMgPSBhZGp1c3RCeURlbHRhKG51bGwsIGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LCBpZEJlZm9yZSwgaWRBZnRlciwgZGVsdGEsIHByZXZTaXplcywgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2UuY3VycmVudCwgbnVsbCk7XG4gICAgaWYgKHByZXZTaXplcyAhPT0gbmV4dFNpemVzKSB7XG4gICAgICBjb25zdCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwID0gcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50O1xuICAgICAgc2V0U2l6ZXMobmV4dFNpemVzKTtcblxuICAgICAgLy8gSWYgcmVzaXplIGNoYW5nZSBoYW5kbGVycyBoYXZlIGJlZW4gZGVjbGFyZWQsIHRoaXMgaXMgdGhlIHRpbWUgdG8gY2FsbCB0aGVtLlxuICAgICAgLy8gVHJpZ2dlciB1c2VyIGNhbGxiYWNrcyBhZnRlciB1cGRhdGluZyBzdGF0ZSwgc28gdGhhdCB1c2VyIGNvZGUgY2FuIG92ZXJyaWRlIHRoZSBzaXplcy5cbiAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbHNBcnJheSwgbmV4dFNpemVzLCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzaXplUGFuZWwgPSB1c2VDYWxsYmFjaygoaWQsIG5leHRTaXplLCB1bml0c0Zyb21QYXJhbXMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogZ3JvdXBJZCxcbiAgICAgIHBhbmVscyxcbiAgICAgIHNpemVzOiBwcmV2U2l6ZXMsXG4gICAgICB1bml0c1xuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBpZiAoKHVuaXRzRnJvbVBhcmFtcyB8fCB1bml0cykgPT09IFwicGl4ZWxzXCIpIHtcbiAgICAgIGNvbnN0IGdyb3VwU2l6ZVBpeGVscyA9IGdldEF2YWlsYWJsZUdyb3VwU2l6ZVBpeGVscyhncm91cElkKTtcbiAgICAgIG5leHRTaXplID0gbmV4dFNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gICAgfVxuICAgIGNvbnN0IHBhbmVsID0gcGFuZWxzLmdldChpZCk7XG4gICAgaWYgKHBhbmVsID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUsXG4gICAgICBjb2xsYXBzaWJsZSxcbiAgICAgIG1heFNpemUsXG4gICAgICBtaW5TaXplXG4gICAgfSA9IHBhbmVsLmN1cnJlbnQ7XG4gICAgaWYgKHVuaXRzID09PSBcInBpeGVsc1wiKSB7XG4gICAgICBjb25zdCBncm91cFNpemVQaXhlbHMgPSBnZXRBdmFpbGFibGVHcm91cFNpemVQaXhlbHMoZ3JvdXBJZCk7XG4gICAgICBtaW5TaXplID0gbWluU2l6ZSAvIGdyb3VwU2l6ZVBpeGVscyAqIDEwMDtcbiAgICAgIGlmIChtYXhTaXplICE9IG51bGwpIHtcbiAgICAgICAgbWF4U2l6ZSA9IG1heFNpemUgLyBncm91cFNpemVQaXhlbHMgKiAxMDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhbmVsc0FycmF5ID0gcGFuZWxzTWFwVG9Tb3J0ZWRBcnJheShwYW5lbHMpO1xuICAgIGNvbnN0IGluZGV4ID0gcGFuZWxzQXJyYXkuaW5kZXhPZihwYW5lbCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHByZXZTaXplc1tpbmRleF07XG4gICAgaWYgKGN1cnJlbnRTaXplID09PSBuZXh0U2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29sbGFwc2libGUgJiYgbmV4dFNpemUgPT09IGNvbGxhcHNlZFNpemUpIDsgZWxzZSB7XG4gICAgICBjb25zdCB1bnNhZmVOZXh0U2l6ZSA9IG5leHRTaXplO1xuICAgICAgbmV4dFNpemUgPSBNYXRoLm1pbihtYXhTaXplICE9IG51bGwgPyBtYXhTaXplIDogMTAwLCBNYXRoLm1heChtaW5TaXplLCBuZXh0U2l6ZSkpO1xuICAgICAge1xuICAgICAgICBpZiAodW5zYWZlTmV4dFNpemUgIT09IG5leHRTaXplKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBzaXplICgke3Vuc2FmZU5leHRTaXplfSkgc3BlY2lmaWVkIGZvciBQYW5lbCBcIiR7cGFuZWwuY3VycmVudC5pZH1cIiBnaXZlbiB0aGUgcGFuZWwncyBtaW4vbWF4IHNpemUgY29uc3RyYWludHNgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbaWRCZWZvcmUsIGlkQWZ0ZXJdID0gZ2V0QmVmb3JlQW5kQWZ0ZXJJZHMoaWQsIHBhbmVsc0FycmF5KTtcbiAgICBpZiAoaWRCZWZvcmUgPT0gbnVsbCB8fCBpZEFmdGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNMYXN0UGFuZWwgPSBpbmRleCA9PT0gcGFuZWxzQXJyYXkubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBkZWx0YSA9IGlzTGFzdFBhbmVsID8gY3VycmVudFNpemUgLSBuZXh0U2l6ZSA6IG5leHRTaXplIC0gY3VycmVudFNpemU7XG4gICAgY29uc3QgbmV4dFNpemVzID0gYWRqdXN0QnlEZWx0YShudWxsLCBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudCwgaWRCZWZvcmUsIGlkQWZ0ZXIsIGRlbHRhLCBwcmV2U2l6ZXMsIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlLmN1cnJlbnQsIG51bGwpO1xuICAgIGlmIChwcmV2U2l6ZXMgIT09IG5leHRTaXplcykge1xuICAgICAgY29uc3QgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudDtcbiAgICAgIHNldFNpemVzKG5leHRTaXplcyk7XG5cbiAgICAgIC8vIElmIHJlc2l6ZSBjaGFuZ2UgaGFuZGxlcnMgaGF2ZSBiZWVuIGRlY2xhcmVkLCB0aGlzIGlzIHRoZSB0aW1lIHRvIGNhbGwgdGhlbS5cbiAgICAgIC8vIFRyaWdnZXIgdXNlciBjYWxsYmFja3MgYWZ0ZXIgdXBkYXRpbmcgc3RhdGUsIHNvIHRoYXQgdXNlciBjb2RlIGNhbiBvdmVycmlkZSB0aGUgc2l6ZXMuXG4gICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxzQXJyYXksIG5leHRTaXplcywgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgYWN0aXZlSGFuZGxlSWQsXG4gICAgY29sbGFwc2VQYW5lbCxcbiAgICBkaXJlY3Rpb24sXG4gICAgZXhwYW5kUGFuZWwsXG4gICAgZ2V0UGFuZWxTaXplLFxuICAgIGdldFBhbmVsU3R5bGUsXG4gICAgZ3JvdXBJZCxcbiAgICByZWdpc3RlclBhbmVsLFxuICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlLFxuICAgIHJlc2l6ZVBhbmVsLFxuICAgIHN0YXJ0RHJhZ2dpbmc6IChpZCwgZXZlbnQpID0+IHtcbiAgICAgIHNldEFjdGl2ZUhhbmRsZUlkKGlkKTtcbiAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpIHx8IGlzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlRWxlbWVudCA9IGdldFJlc2l6ZUhhbmRsZShpZCk7XG4gICAgICAgIGluaXRpYWxEcmFnU3RhdGVSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICBkcmFnSGFuZGxlUmVjdDogaGFuZGxlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBkcmFnT2Zmc2V0OiBnZXREcmFnT2Zmc2V0KGV2ZW50LCBpZCwgZGlyZWN0aW9uKSxcbiAgICAgICAgICBzaXplczogY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQuc2l6ZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BEcmFnZ2luZzogKCkgPT4ge1xuICAgICAgcmVzZXRHbG9iYWxDdXJzb3JTdHlsZSgpO1xuICAgICAgc2V0QWN0aXZlSGFuZGxlSWQobnVsbCk7XG4gICAgICBpbml0aWFsRHJhZ1N0YXRlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH0sXG4gICAgdW5pdHMsXG4gICAgdW5yZWdpc3RlclBhbmVsXG4gIH0pLCBbYWN0aXZlSGFuZGxlSWQsIGNvbGxhcHNlUGFuZWwsIGRpcmVjdGlvbiwgZXhwYW5kUGFuZWwsIGdldFBhbmVsU2l6ZSwgZ2V0UGFuZWxTdHlsZSwgZ3JvdXBJZCwgcmVnaXN0ZXJQYW5lbCwgcmVnaXN0ZXJSZXNpemVIYW5kbGUsIHJlc2l6ZVBhbmVsLCB1bml0cywgdW5yZWdpc3RlclBhbmVsXSk7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGZsZXhEaXJlY3Rpb246IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcInJvd1wiIDogXCJjb2x1bW5cIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIlxuICB9O1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChQYW5lbEdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIGNoaWxkcmVuOiBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMsXG4gICAgICBcImRhdGEtcGFuZWwtZ3JvdXBcIjogXCJcIixcbiAgICAgIFwiZGF0YS1wYW5lbC1ncm91cC1kaXJlY3Rpb25cIjogZGlyZWN0aW9uLFxuICAgICAgXCJkYXRhLXBhbmVsLWdyb3VwLWlkXCI6IGdyb3VwSWQsXG4gICAgICBcImRhdGEtcGFuZWwtZ3JvdXAtdW5pdHNcIjogdW5pdHMsXG4gICAgICBzdHlsZToge1xuICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICAgIH1cbiAgICB9KSxcbiAgICB2YWx1ZTogY29udGV4dFxuICB9KTtcbn1cbmNvbnN0IFBhbmVsR3JvdXAgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBjcmVhdGVFbGVtZW50KFBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmLCB7XG4gIC4uLnByb3BzLFxuICBmb3J3YXJkZWRSZWY6IHJlZlxufSkpO1xuUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYuZGlzcGxheU5hbWUgPSBcIlBhbmVsR3JvdXBcIjtcblBhbmVsR3JvdXAuZGlzcGxheU5hbWUgPSBcImZvcndhcmRSZWYoUGFuZWxHcm91cClcIjtcblxuZnVuY3Rpb24gUGFuZWxSZXNpemVIYW5kbGUoe1xuICBjaGlsZHJlbiA9IG51bGwsXG4gIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzID0gXCJcIixcbiAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgaWQ6IGlkRnJvbVByb3BzID0gbnVsbCxcbiAgb25EcmFnZ2luZyxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzID0ge30sXG4gIHRhZ05hbWU6IFR5cGUgPSBcImRpdlwiXG59KSB7XG4gIGNvbnN0IGRpdkVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgLy8gVXNlIGEgcmVmIHRvIGd1YXJkIGFnYWluc3QgdXNlcnMgcGFzc2luZyBpbmxpbmUgcHJvcHNcbiAgY29uc3QgY2FsbGJhY2tzUmVmID0gdXNlUmVmKHtcbiAgICBvbkRyYWdnaW5nXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uRHJhZ2dpbmcgPSBvbkRyYWdnaW5nO1xuICB9KTtcbiAgY29uc3QgcGFuZWxHcm91cENvbnRleHQgPSB1c2VDb250ZXh0KFBhbmVsR3JvdXBDb250ZXh0KTtcbiAgaWYgKHBhbmVsR3JvdXBDb250ZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhbmVsUmVzaXplSGFuZGxlIGNvbXBvbmVudHMgbXVzdCBiZSByZW5kZXJlZCB3aXRoaW4gYSBQYW5lbEdyb3VwIGNvbnRhaW5lcmApO1xuICB9XG4gIGNvbnN0IHtcbiAgICBhY3RpdmVIYW5kbGVJZCxcbiAgICBkaXJlY3Rpb24sXG4gICAgZ3JvdXBJZCxcbiAgICByZWdpc3RlclJlc2l6ZUhhbmRsZSxcbiAgICBzdGFydERyYWdnaW5nLFxuICAgIHN0b3BEcmFnZ2luZ1xuICB9ID0gcGFuZWxHcm91cENvbnRleHQ7XG4gIGNvbnN0IHJlc2l6ZUhhbmRsZUlkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBpc0RyYWdnaW5nID0gYWN0aXZlSGFuZGxlSWQgPT09IHJlc2l6ZUhhbmRsZUlkO1xuICBjb25zdCBbaXNGb2N1c2VkLCBzZXRJc0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcmVzaXplSGFuZGxlciwgc2V0UmVzaXplSGFuZGxlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgc3RvcERyYWdnaW5nQW5kQmx1ciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAvLyBDbGlja2luZyBvbiB0aGUgZHJhZyBoYW5kbGUgc2hvdWxkbid0IGxlYXZlIGl0IGZvY3VzZWQ7XG4gICAgLy8gVGhhdCB3b3VsZCBjYXVzZSB0aGUgUGFuZWxHcm91cCB0byB0aGluayBpdCB3YXMgc3RpbGwgYWN0aXZlLlxuICAgIGNvbnN0IGRpdiA9IGRpdkVsZW1lbnRSZWYuY3VycmVudDtcbiAgICBkaXYuYmx1cigpO1xuICAgIHN0b3BEcmFnZ2luZygpO1xuICAgIGNvbnN0IHtcbiAgICAgIG9uRHJhZ2dpbmdcbiAgICB9ID0gY2FsbGJhY2tzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKG9uRHJhZ2dpbmcpIHtcbiAgICAgIG9uRHJhZ2dpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3N0b3BEcmFnZ2luZ10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgc2V0UmVzaXplSGFuZGxlcihudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzaXplSGFuZGxlciA9IHJlZ2lzdGVyUmVzaXplSGFuZGxlKHJlc2l6ZUhhbmRsZUlkKTtcbiAgICAgIHNldFJlc2l6ZUhhbmRsZXIoKCkgPT4gcmVzaXplSGFuZGxlcik7XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIHJlc2l6ZUhhbmRsZUlkLCByZWdpc3RlclJlc2l6ZUhhbmRsZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCByZXNpemVIYW5kbGVyID09IG51bGwgfHwgIWlzRHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25Nb3ZlID0gZXZlbnQgPT4ge1xuICAgICAgcmVzaXplSGFuZGxlcihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdXNlTGVhdmUgPSBldmVudCA9PiB7XG4gICAgICByZXNpemVIYW5kbGVyKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IGRpdkVsZW1lbnQgPSBkaXZFbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgdGFyZ2V0RG9jdW1lbnQgPSBkaXZFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW92ZSk7XG4gICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7XG4gICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBvbk1vdXNlTGVhdmUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0YXJnZXREb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBzdG9wRHJhZ2dpbmdBbmRCbHVyKTtcbiAgICAgIHRhcmdldERvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdmUpO1xuICAgICAgdGFyZ2V0RG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7XG4gICAgICB0YXJnZXREb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG9uTW91c2VMZWF2ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgc3RvcERyYWdnaW5nQW5kQmx1cik7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHN0b3BEcmFnZ2luZ0FuZEJsdXIpO1xuICAgIH07XG4gIH0sIFtkaXJlY3Rpb24sIGRpc2FibGVkLCBpc0RyYWdnaW5nLCByZXNpemVIYW5kbGVyLCBzdG9wRHJhZ2dpbmdBbmRCbHVyXSk7XG4gIHVzZVdpbmRvd1NwbGl0dGVyUmVzaXplSGFuZGxlckJlaGF2aW9yKHtcbiAgICBkaXNhYmxlZCxcbiAgICBoYW5kbGVJZDogcmVzaXplSGFuZGxlSWQsXG4gICAgcmVzaXplSGFuZGxlclxuICB9KTtcbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgY3Vyc29yOiBnZXRDdXJzb3JTdHlsZShkaXJlY3Rpb24pLFxuICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcbiAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIlxuICB9O1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChUeXBlLCB7XG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMsXG4gICAgXCJkYXRhLXJlc2l6ZS1oYW5kbGUtYWN0aXZlXCI6IGlzRHJhZ2dpbmcgPyBcInBvaW50ZXJcIiA6IGlzRm9jdXNlZCA/IFwia2V5Ym9hcmRcIiA6IHVuZGVmaW5lZCxcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbixcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZCxcbiAgICBcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1lbmFibGVkXCI6ICFkaXNhYmxlZCxcbiAgICBcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZFwiOiByZXNpemVIYW5kbGVJZCxcbiAgICBvbkJsdXI6ICgpID0+IHNldElzRm9jdXNlZChmYWxzZSksXG4gICAgb25Gb2N1czogKCkgPT4gc2V0SXNGb2N1c2VkKHRydWUpLFxuICAgIG9uTW91c2VEb3duOiBldmVudCA9PiB7XG4gICAgICBzdGFydERyYWdnaW5nKHJlc2l6ZUhhbmRsZUlkLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ2dpbmdcbiAgICAgIH0gPSBjYWxsYmFja3NSZWYuY3VycmVudDtcbiAgICAgIGlmIChvbkRyYWdnaW5nKSB7XG4gICAgICAgIG9uRHJhZ2dpbmcodHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbk1vdXNlVXA6IHN0b3BEcmFnZ2luZ0FuZEJsdXIsXG4gICAgb25Ub3VjaENhbmNlbDogc3RvcERyYWdnaW5nQW5kQmx1cixcbiAgICBvblRvdWNoRW5kOiBzdG9wRHJhZ2dpbmdBbmRCbHVyLFxuICAgIG9uVG91Y2hTdGFydDogZXZlbnQgPT4ge1xuICAgICAgc3RhcnREcmFnZ2luZyhyZXNpemVIYW5kbGVJZCwgZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkRyYWdnaW5nXG4gICAgICB9ID0gY2FsbGJhY2tzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAob25EcmFnZ2luZykge1xuICAgICAgICBvbkRyYWdnaW5nKHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVmOiBkaXZFbGVtZW50UmVmLFxuICAgIHJvbGU6IFwic2VwYXJhdG9yXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIHRhYkluZGV4OiAwXG4gIH0pO1xufVxuUGFuZWxSZXNpemVIYW5kbGUuZGlzcGxheU5hbWUgPSBcIlBhbmVsUmVzaXplSGFuZGxlXCI7XG5cbmV4cG9ydCB7IFBhbmVsLCBQYW5lbEdyb3VwLCBQYW5lbFJlc2l6ZUhhbmRsZSwgZ2V0QXZhaWxhYmxlR3JvdXBTaXplUGl4ZWxzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js\n");

/***/ })

};
;